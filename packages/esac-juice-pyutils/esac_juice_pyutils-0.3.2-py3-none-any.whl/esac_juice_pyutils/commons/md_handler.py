"""
Created on October, 2017

@author: Claudio Munoz Crego (ESAC)

This file ...
"""

import os
import sys
import logging
import subprocess
import datetime


class MdHandler(object):
    """

    """

    def __init__(self, output_path, out=sys.stdout,
                 start=datetime.datetime.now(), end=datetime.datetime.now()):
        """
        :param out: unit where to write report summary
        """

        self.output_path = output_path
        self.out = self.reset_out(out)
        self.start = start
        self.end = end

    def reset_out(self, out):
        """
        Reset the output stream

        :param out: unit where to write report summary
        :return: unit where to write report summary
        """

        if out == "md":
            self.md_file_name = os.path.join(self.output_path, 'report.rst')
            out = open(os.path.join(self.output_path, 'report.md'), 'w')

        return out

    def write_text(self, text):
        """
        write normal text

        :param text:
        :return:
        """

        self.out.write(text)

    def write_heading(self, level='#', text='heading'):
        """
        Write heading

            # with overline, for parts
            * with overline, for chapters
            =, for sections
            -, for subsections
            ^, for subsubsections
            ", for paragraphs
        :param text:
        :param level:
        :return:
        """

        title_size = len(text)
        #self.out.write('\n{}\n'.format(level * title_size))
        self.out.write('{} {}'.format(level, text))
        #self.out.write('\n{}\n'.format(level * title_size))

    def write_head_chapter(self, text):
        """
        Write head chapter
        :param text:
        :return:
            """
        self.write_heading('#', text)

    def write_head_section(self, text):
        """
        Write head section
        :param text:
        :return:
            """
        self.out.write('\n')
        self.write_heading('##', text)

    def write_head_subsection(self, text):
        """
        Write head subsection
        :param text:
        :return:
        """
        self.out.write('\n')
        self.write_heading('###', text)

    def write_head_subsubsection(self, text):
        """
        Write head subsubsection
        :param text:
        :return:
        """
        self.write_heading('####', text)

       # def reST_to_html_fragment(self, a_str):
    #
    #     from docutils import core
    #     parts = core.publish_parts(
    #         source=a_str,
    #         writer_name='html')
    #     return parts['body_pre_docinfo'] + parts['fragment']
    #
    # def reST_to_html_file(self, md_path_file=''):
    #
    #     f = open(os.path.join(self.output_path, 'report_metrics_summary.md'), 'r')
    #
    #     a_str = '\n'.join(f.readlines())
    #
    #     html_str = self.reST_to_html_fragment(a_str)
    #
    #     f = open(os.path.join(self.output_path, 'report_metrics_summary.html'), 'w')

    def print_introduction(self):
        """
        Print intro
        """
        total_duration = self.end - self.start

        intro = ("\n"
                 "This document was automatically generated by Simu Dust Particle Tool on |date| at |time|.\n\n"
                 "Scenario start: {0}\n"
                 "Scenario end: {1}\n"
                 "Scenario Duration: {2}\n"
                 "\n").format(self.start, self.end, total_duration)

        self.out.write(intro)

    def print_md_table(self, metrics, title=True):
        """
        Generate (print) a table in md format

        :param title: flag which specify if the table have a title line or not.
        :param metrics: list of table lines, if title=True, the title must be in metrics[0]
        :param out: unit where to write report summary
        :return:
        """

        # convert all elements to strings
        for i in range(len(metrics)):
            metrics[i] = [str(ele) for ele in metrics[i]]

        d = []
        table_title_format = '|'
        table_line_format = '|'

        for i in range(len(metrics[0])):
            # print 'i = ', i, len(metrics[0])
            d.append(len(max([str(ele[i]) for ele in metrics], key=len)))
            table_title_format += ' {' + str(i) + ':' + str(d[i]) + 's} |'
            # table_line_format += ' {' + str(i) + ':' + str(d[i]) + 's} |'
        table_title_format += '\n'
        # table_line_format += '\n'

        # table_line = ''
        table_line_title = ''
        for i in range(len(d)):
            # table_line += '|{}'.format('-' * (d[i] + 2))
            table_line_title += '|{}'.format('-' * (d[i] + 2))

        # table_line += '+\n'
        table_line_title += '+\n'

        if title:
            # self.out.write(table_line)
            self.out.write(table_title_format.format(*metrics[0]))
            self.out.write(table_line_title)
            metrics.pop(0)
        # else:
            # self.out.write(table_line)

        for ele in metrics:
            self.out.write(table_line_format.format(*ele))
            # self.out.write(table_line)

        self.out.write('\n')

    def print_md_metrics_summary_table(self, metrics):
        """
        Generate summary metric table

        :param metrics list of table lines
        :param out: unit where to write report summary
        """

        metrics.insert(0,['Metric', 'Value', 'Unit'])
        self.print_md_table(metrics)

    def md_insert_figure(self, fig_path, title, text=[]):
        """
        Write md instructions to include a figure
        :param out: unit where to write report summary
        :param fig_path: path of figure file
        :param title: figure title
        :param text: some text
        :return:
        """

        if text != '':
            text = "   This figure includes {}\n".format(text)
        fig = ("\n"
               " []: (})\n"
               "->**{}**<-"
               ).format(fig_path, title, text)

        self.out.write(fig)

    def rst_to_html(self):

        f_in = os.path.join(self.output_path, 'report.md')
        f_out = os.path.join(self.output_path, 'report.html')
        command = 'rst2html5.py {} {} '.format(f_in, f_out)

        logging.info('running os command "{}'.format(command))
        # os.system(command)

        try:
            p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)

            while True:
                line = p.stdout.readline()
                if not line: break
                print('{}'.format(line))
            p.wait()

            if p.returncode != 0:
                p.terminate()

            logging.info('file {} generated '.format(f_out))

        except Exception:
            logging.error('command failed:  {} '.format(command))
            logging.warning('file {} cannot be generated '.format(f_out))

    def html_to_pdf(self):
        """

        Requires
        linux: sudo apt-get install wkhtmltopdf
        mac os: brew install Caskroom/cask/wkhtmltopdf
        pip install wkhtmltopdf
        pip install pdfkit
        :return:
        """

        f_in = os.path.join(self.output_path, 'report.html')
        f_out = os.path.join(self.output_path, 'report.pdf')

        import pdfkit

        options = {
                'page-size': 'A4',
                'margin-top': '0.75in',
                'margin-right': '0.75in',
                'margin-bottom': '0.75in',
                'margin-left': '0.75in',
                'dpi':400,
                }

        try :
            pdfkit.from_file([f_in], f_out, options=options)
            logging.info('file {} generated '.format(f_out))
        except: # catch *all* exceptions
            e = sys.exc_info()
            print(e[0])
            for ele in e[1]:
                print('{}'.format(ele))
            logging.error('file {} generated '.format(f_out))

    def pandoc_docx_to_md(self, input_path_file, output_path_file=''):

        if output_path_file == '':
            output_path_file = input_path_file.replace('.docx', '.md')
        self.pandoc_convert(input_path_file, output_path_file)

    def pandoc_md_to_docx(self, input_path_file='', output_path_file=''):

        if input_path_file == '':
            input_path_file = self.md_file_name

        if output_path_file == '':
            output_path_file = input_path_file.replace('.md', '.docx')
        self.pandoc_convert(input_path_file, output_path_file)

    def pandoc_md_to_pdf(self, input_path_file, output_path_file=''):
        """

        Note : by command line
        pandoc -s my_file.docx -t md -o my_file.md
        :param input_path_file:
        :param output_path_file:
        :return:
        """

        if output_path_file == '':
            output_path_file = input_path_file.replace('.md', '.pdf')
        self.pandoc_convert(input_path_file, output_path_file)

    def pandoc_convert(self, input_path_file, output_path_file):
        """
        Requires:

        brew install pandoc
        brew cask install basictex (to support pdf)
        pip install pypandoc


        :param input_path_file:
        :param output_path_file:
        :return:
        """
        import pypandoc

        output_type = os.path.basename(output_path_file).split('.')[1]
        output = pypandoc.convert_file(input_path_file, output_type, outputfile=output_path_file)
