import os
import sys
import subprocess
from dotenv import load_dotenv
from colorama import Fore

from tasks.utils import create_checkpoint, safety_verification
from config.ai_config import send_and_print_message
from config.ai_config import create_chat_session
from tasks.install_util import install_package

"""
Utils qui servent à multitask
"""

# Charger les variables d'environnement depuis .env
load_dotenv()

prompt_version = os.getenv("PROMPT_VERSION")
if not prompt_version:
    print("Votre prompt n'a pas été trouvé, veuillez vérifier le fichier .env")
    sys.exit(1)

# Importation dynamique du module de prompt en fonction de la version
prompt_module = __import__(f"prompts.{prompt_version}", fromlist=['Pentestprompt'])
Pentestprompt = getattr(prompt_module, 'Pentestprompt')


def init_multitask():
    api_key = os.getenv("API_KEY")
    if not api_key:
        print('Votre clé API n\'est pas définie.')
        sys.exit(1)

    pt = Pentestprompt()
    sessions = [create_chat_session(api_key) for _ in range(4)]
    reasoning_session, generation_session, parsing_session, final_session = sessions

    # Initialisation des sessions
    send_and_print_message("init_session_reason",reasoning_session, pt.specialized_tree)
    send_and_print_message("init_session_gen", generation_session, pt.generation_session_init)
    send_and_print_message("init_session_parse", parsing_session, pt.input_parsing_init)

    return reasoning_session, generation_session, parsing_session

def read_files(utils_multitask, task):
    try:
        pt=Pentestprompt()
        path = "outputs/raw"
        print("Before listdir")
        file_list = os.listdir(path)
        print("File list: ", file_list)
        file_to_read = send_and_print_message("read_files_session", utils_multitask, f"{pt.file_read}\nList of files:\n{file_list}\nTask to do: {task}\n")
        print("File to read: ", file_to_read)
        with open(f"{path}/{file_to_read}", "r") as file:
            content = file.read()
            print("Content: ", content)
        return content #send_and_print_message("read_files_session", specialized_session, content)
    except FileNotFoundError:
        print(f"Fichier non trouvé.")
        sys.exit(1)
    except Exception as e:
        print(f"Erreur: {e}.")
        sys.exit(1)
    


def web_crawl(generation_session,parsing_session, target_info):
    pass


def help_section(generation_session,parsing_session, task, target_info):
    """
    Crée une commande basée sur la tâche et les informations sur la cible.
    Help section à ajouter seulement si la commande fail
    Penser à modifier aussi le prompt
    """
    pt = Pentestprompt()

    command=send_and_print_message("command_session",generation_session, f"{pt.todo_to_command}\nTask: {task}\n")
    result = subprocess.run([command.split()[0], '--help'], capture_output=True, text=True, check=True)
    help_section=send_and_print_message("help_session",parsing_session,result.stdout)
    
    return help_section

def finish(reasoning_session,task_tree):
    end_task=send_and_print_message("finish_session", reasoning_session,"If every task is 'completed' or non applicable, answer with FINISH. Answer with YES and nothing else if you understood. Here is the task tree :"+task_tree)
    return end_task