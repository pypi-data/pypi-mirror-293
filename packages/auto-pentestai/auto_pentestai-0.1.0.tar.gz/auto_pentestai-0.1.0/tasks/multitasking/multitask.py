import os
import sys
import subprocess
from dotenv import load_dotenv
from colorama import Fore

from tasks.utils import create_checkpoint, safety_verification
from tasks.task_execution import analyse
from config.ai_config import send_and_print_message
from tasks.install_util import install_package
from tasks.multitasking.utils_multitask import read_files, web_crawl, help_section, init_multitask
from tasks.target_info import get_target_info # OK

"""
Multitask permet de réaliser les fonctions difficiles à réaliser en une seule tâche.
Prompt specialized_tree OK for init specialized
Prompt specialized_task_description OK for specialized_task_tree
Prompt specialized_result_task_selection OK for task_specialized
Prompt process_results OLD for update_tree
Prompt command_spe OK for command
"""

# Charger les variables d'environnement depuis .env
load_dotenv()

prompt_version = os.getenv("PROMPT_VERSION")
if not prompt_version:
    print("Votre prompt n'a pas été trouvé, veuillez vérifier le fichier .env")
    sys.exit(1)

# Importation dynamique du module de prompt en fonction de la version
prompt_module = __import__(f"prompts.{prompt_version}", fromlist=['Pentestprompt'])
Pentestprompt = getattr(prompt_module, 'Pentestprompt')


def specialized_task_tree(specialized_session, task, target_info):
    """
    Crée un arbre de tâches spécialisé pour une tâche compliquée.
    """
    pt = Pentestprompt()
    checkpoint = create_checkpoint(task, target_info)
    return send_and_print_message("specialized_task_tree", specialized_session, f"{pt.specialized_task_description}\n{checkpoint}") #FAIT


def task_specialized(specialized_session, task_tree, target_info):
    """
    Sélectionne et initialise une tâche à partir des informations sur la cible.
    """
    priority_tool = os.getenv("PRIORITY_TOOL")

    if not priority_tool:
        print('Fichier des outils préférés non trouvé. Pensez à changer le PATH dans le .env')
        sys.exit(1)

    pt = Pentestprompt()
    checkpoint = create_checkpoint(task_tree, target_info)
    return send_and_print_message("task_session", specialized_session, f"{pt.specialized_results_task_selection}\n{checkpoint}") #FAIT


def update_tree(specialized_session, target_info, task_tree, output_cmd):
    """
    Met à jour l'arbre des tâches avec les résultats de l'analyse.
    """
    pt = Pentestprompt()
    checkpoint = create_checkpoint(task_tree, target_info)
    return send_and_print_message("update_tree_session", specialized_session, f"{pt.process_results}\n{checkpoint}\nTest result:\n\n{output_cmd}")


def command(specialized_session, generation_session, parsing_session, task, target_info):
    """
    Exécute une commande, en fonction des choix entre read, curl, help ou command.
    """
    pt = Pentestprompt()
    result = send_and_print_message("command_session", specialized_session, f"{pt.command_spe}\n{task}")
    print("\nTask: ",task)
    print("\nCommand: ",result)
    more_info = None
    if "read" in result.lower():
        more_info = read_files(specialized_session, task)
    # elif "curl" in result.lower():
    #     more_info = web_crawl(generation_session, parsing_session, target_info)
    elif "help" in result.lower():
        more_info = help_section(generation_session, parsing_session, task, target_info)
    
    command_str = send_and_print_message("final_command_session", specialized_session, f"{pt.todo_to_command}\nTask: {task}\n{target_info.get_summary()}\nMore info: {more_info}")
    print("Command str: ",command_str)
    output = run(command_str)
    
    return output


def run(cmd):
    """
    Exécute la commande si elle est autorisée, sinon relance la tâche avec une nouvelle commande.
    """
    if 1==1 or safety_verification(cmd):
        install_package(cmd.split()[0])  # Vérification d'installation du paquet

        print(Fore.YELLOW + f"Entrer cette commande ? :\n{cmd}")
        confirmation = input(Fore.RESET + "Confirmez avec 'yes' pour continuer: ").strip().lower()
        
        if confirmation:
            command_valid = ["yes ' '", "|"] + [cmd]
            result = subprocess.run(" ".join(command_valid), shell=True, capture_output=True, text=True)
            print("Sortie de la commande :")
            print(result.stdout)
            return result.stdout
        else:
            print(Fore.RED + "Commande annulée par l'utilisateur.")
    else:
        print(Fore.RED + "Commande non autorisée par la vérification de sécurité.")

    return "Command failed, please retry"


def multitask(task, target_info, specialized_session, generation_session, parsing_session):
    
    """
    Fonction principale de multitask.
    """
    spe_task_tree = specialized_task_tree(specialized_session, task, target_info)
    print(spe_task_tree)

    end = ""
    while "FINISH" not in end:
        spe_task = task_specialized(specialized_session, spe_task_tree, target_info)
        print(spe_task)
        output_cmd = command(specialized_session, generation_session, parsing_session, spe_task, target_info)
        spe_task_tree=update_tree(specialized_session, target_info, spe_task_tree, output_cmd)
        #analyse_cmd=analyse(parsing_session, output_cmd)
        end=send_and_print_message("finish_session", specialized_session,"If every task is 'completed' or non applicable, answer with FINISH. Answer with YES and nothing else if you understood. Here is the task tree :"+spe_task_tree)

    print(Fore.GREEN + "Toutes les tâches sont terminées.")

