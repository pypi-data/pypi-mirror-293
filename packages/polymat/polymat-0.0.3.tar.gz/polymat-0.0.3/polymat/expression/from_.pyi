from typing import Iterable, overload

from polymat.expression.abc import (
    MatrixExpression,
    RowVectorExpression,
    SymmetricMatrixExpression,
    VectorExpression,
    PolynomialExpression,
    SingleDimVariableExpression,
    VariableVectorExpression,
    VariableExpression,
)
from polymat.expressiontree.operations.fromanymixin import FromAnyMixin
from polymat.expressiontree.operations.fromvariablesmixin import FromVariablesMixin
from polymat.utils.typing import FROM_TYPES

@overload
def block_diag(expressions: Iterable[SymmetricMatrixExpression]) -> SymmetricMatrixExpression: ...
@overload
def block_diag(expressions: Iterable[MatrixExpression]) -> MatrixExpression: ...
def concat(expressions: Iterable[Iterable[MatrixExpression]]): ...
def from_(value: FROM_TYPES) -> MatrixExpression: ...
def from_symmetric(value: FROM_TYPES) -> SymmetricMatrixExpression: ...
def from_vector(value: FROM_TYPES) -> VectorExpression: ...
def from_row_vector(value: FROM_TYPES) -> RowVectorExpression: ...
def from_polynomial(value: FromAnyMixin.VALUE_TYPES) -> PolynomialExpression: ...
@overload
def define_variable(
    name: str,
    size: int | MatrixExpression | None,
) -> VariableExpression: ...
@overload
def define_variable(
    name: str,
) -> SingleDimVariableExpression: ...
def from_variables(
    variables: FromVariablesMixin.VARIABLE_TYPE,
) -> VariableVectorExpression: ...
def from_variable_indices(indices: tuple[int, ...]) -> VariableVectorExpression: ...
@overload
def h_stack(expressions: Iterable[RowVectorExpression]) -> RowVectorExpression: ...
@overload
def h_stack(expressions: Iterable[MatrixExpression]) -> MatrixExpression: ...
def product(expressions: Iterable[VectorExpression]) -> VectorExpression: ...
@overload
def v_stack(expressions: Iterable[VariableExpression]) -> VariableVectorExpression: ...
@overload
def v_stack(
    expressions: Iterable[VariableVectorExpression],
) -> VariableVectorExpression: ...
@overload
def v_stack(expressions: Iterable[VectorExpression]) -> VectorExpression: ...
@overload
def v_stack(expressions: Iterable[MatrixExpression]) -> MatrixExpression: ...
