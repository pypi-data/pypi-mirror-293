'''
gromacsの出力ファイル（temp.groなど）
からCPMD/QE用の出力を作成する．
'''
import ase.io

class make_cpmdinput():
     # pseudo potentialの辞書を作成．
     # TODO :: hard code :: いずれは擬ポテンシャルも指定できると良い．
     pseudo = {}
     # goedecker
     # pseudo["O"]="O_SG_BLYP"
     # pseudo["H"]="H_SG_BLYP"
     # pseudo["C"]="C_SG_BLYP"
     pseudo["N"]="N_SG_BLYP"

     # MT
     pseudo["O"]="O_MT_GIA_BLYP"
     pseudo["H"]="H_MT_BLYP.psp" # 2024/1/9 H_GIA_BLYPから変更
     pseudo["C"]="C_MT_GIA_BLYP"
     
     
     def __init__(self, ase_atoms):
         # get supercell size
         # * TODO :: hard code : simple cubic only !!
         self.cell_parameter=ase_atoms.get_cell()[0][0] # 00の対角成分をとる．
         self.ase_atoms=ase_atoms

         self.lines_georelax='''
&INFO
   input generated by dieltools
   Bulk .
   --------
   Functional : GGA (?)
&END
         
&CPMD
   OPTIMIZE GEOMETRY XYZ
   MIRROR
   FILEPATH
         ./tmp         
   CONVERGENCE GEOMETRY
         1.0e-2
   CONVERGENCE ORBITALS
         1.0e-7
   PRINT FORCES ON
   MAXSTEP
         10000
   VDW CORRECTION ON
&END
         
&SYSTEM
   !! type of symmetry
   !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
   SYMMETRY
         1
   ANGSTROM
   CELL
         {0:.10f} 1.0 1.0  0.0  0.0  0.0
   CUTOFF
         70.0
&END
         
&DFT
   FUNCTIONAL BLYP
&END
         
&VDW
   EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
   END EMPIRICAL CORRECTION
&END
         
&ATOMS
   '''.format(self.cell_parameter)

         self.lines_bomd_relax='''
 &INFO
  input generated by dieltools :: bomd relax calculation(3ps)
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS BO
  MIRROR
  RESTART WAVEFUNCTION COORDINATES LATEST
        
  ! frequency to sample coordinate to save xyz
  TRAJECTORY XYZ FORCES SAMPLE
    1
     
  FILEPATH
   ./tmp
   
  ! Initial temperature      
  TEMPERATURE
   300.0D0
         
  ! You can use both BRENDSEN and NOSE 
  ! In brendren, frequency is given in (timestep)
  ! In NOSE, frequency is given in (cm-1)
  ! berendsen ions, give frequency 10000
  NOSE IONS MASSIVE
   300.0D0 500
         
  MAXSTEP
   3000
  TIMESTEP
   40.0
  PRINT FORCES ON
  !RATTLE
  ! 100 1e-6
  VDW CORRECTION ON
      
  &END
         
  &SYSTEM
     !! type of symmetry
     !! Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
         SYMMETRY
         1
         ANGSTROM
         CELL
         {0:.10f} 1.0 1.0  0.0  0.0  0.0

         CUTOFF
          70.0
  &END
         
  &DFT
         FUNCTIONAL BLYP
  &END
         
         &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
         &END

         &ATOMS
         '''.format(self.cell_parameter)

         # =====  以下のコードは現状利用していないが，将来のために残しておく =====
         # CPMDでは，原子種類ごとに
         '''
         *pseudo/O_SG_BLYP KLEINMAN-BYLANDER
         LMAX=P
         32
         '''
         # みたいなのが必要．ということで，indexが入れ替わるごとに数が必要．
         
         # 連続する同じ原子種のリストを作成
         number_index= []
         pre_index=""
         counter=1
         for i,index in enumerate(self.ase_atoms.get_chemical_symbols()):
             if i == 0:
                 pre_index = index # pre_indexを代入しないとだめ． 
                 continue
             if i == len(self.ase_atoms.get_chemical_symbols())-1: #最後の原子種
                 counter = counter + 1
                 number_index.append(counter)
             if index == pre_index:
                 counter = counter+1
             elif index != pre_index:
                 number_index.append(counter) # 一つ前の原子種の数をappend
                 counter = 1 # リセット
             pre_index = index

         # わかりやすいようにnumber_indexの形を整える．
         new_index=[]
         for i in number_index:
             for j in range(i):
                 new_index.append(i)
         # print(new_index)
         self.new_index=new_index

     # !! 2024/1/16: 入力に必要な要素を個別に分割しておく．
     def make_INFO(self):
          lines= '''
&INFO
  input generated by dieltools :: bomd relax calculation(3ps)
  Bulk .
  --------
  Functional : GGA (?)
 &END
''' 
          return lines
     
     def make_VDW(self):
          """VDW用の入力作成
          基本的にはDFT-D2で固定
          """
          lines='''
&VDW
     EMPIRICAL CORRECTION
     VDW PARAMETERS
     ALL DFT-D2
     END EMPIRICAL CORRECTION
&END
          
          '''
          return lines
     
     


     def make_georelax(self,type="default"):
          # 
          filename_georelax="georelax.inp"

          f_georelax=open(filename_georelax,mode="w")
          f_georelax.write(self.lines_georelax)

          # 最終的な出力を作成．
          if type == "default":
               self.write_coordinates(f_georelax) # 座標を出力
          if type == "sorted":
               self.write_coordinates_type2(f_georelax) # 座標を出力
               
          f_georelax.write("&END")
          f_georelax.close()
          return 0

     def make_bomd_relax(self,type="defualt"):
          """座標を引き継ぐrestartのNVT計算

          あくまで緩和用で，wannierの収集は行わない．
          Args:
              type (str, optional): _description_. Defaults to "defualt".

          Returns:
              _type_: _description_
          """
          
          # 
          filename_bomd="bomd-relax.inp"
          
          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(self.lines_bomd_relax)
          # 最終的な出力を作成．
          if type == "default":
               self.write_coordinates(f_bomd) # 座標を出力
          if type == "sorted":
               self.write_coordinates_type2(f_bomd) # 座標を出力
          
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0

     def make_bomd(self,max_step:float=10000,timestep:float=40,type="default"):
          """座標と波動関数を引き継いでNVTでwannierを計算する．

          Args:
              max_step (float, optional): 最大のステップ数．Defaults to 10000.
              timestep (float, optional): タイムステップ．bomdの場合，40(1fs)以下を推奨．20(0.5fs)なども良い．Defaults to 40.
              type (str, optional): _description_. Defaults to "default".
          """
          
          lines_bomd_restart='''
 &INFO
  input generated by dieltools :: bomd+wf calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS BO
  MIRROR
  RESTART WAVEFUNCTION COORDINATES VELOCITIES LATEST
        
  TRAJECTORY XYZ FORCES SAMPLE
     1
  FILEPATH
   ./tmp
         
  TEMPERATURE
   300.0D0
         
  BERENDSEN IONS
   300.0D0 10000
         
  MAXSTEP
   {0}
  TIMESTEP
   {1}
  PRINT FORCES ON
  VDW CORRECTION ON
      
&END
         
&SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
    SYMMETRY
         1
    ANGSTROM
    CELL
         {2:.10f} 1.0 1.0  0.0  0.0  0.0

    CUTOFF
          70.0
&END
         
&DFT
     FUNCTIONAL BLYP
&END
         
&VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
&END

&ATOMS
         '''.format(max_step,timestep,self.cell_parameter)

          filename_bomd="bomd-restart.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_bomd_restart)
          # 最終的な出力を作成．
          if type == "default":
               self.write_coordinates(f_bomd) # 座標を出力
          if type == "sorted":
               self.write_coordinates_type2(f_bomd) # 座標を出力
          
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0

     def make_bomd_restart(self,max_step:float=10000,timestep:float=40,type="default"):
          """座標，速度を引き継ぐrestartのNVT計算

          !! 現在利用している関数
          各ステップでwannierの収集も実行する．
          Args:
              max_step (float, optional): _description_. Defaults to 10000.
              timestep (float, optional): _description_. Defaults to 40.
              type (str, optional): _description_. Defaults to "default".
          """

          
          lines_bomd_wan_restart='''
 &INFO
  input generated by dieltools :: restart calculation :: bomd+wf calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS BO
  MIRROR
  ! NOSEP restart nose ions thermostat
  RESTART WAVEFUNCTION COORDINATES VELOCITIES LATEST NOSEP {0}
        
  TRAJECTORY XYZ FORCES SAMPLE
     1
     
  FILEPATH
   ./tmp
         
  ! if you use berendsen thermostat,
  ! berendsen ions, 300.0 10000
  NOSE IONS MASSIVE
   300.0D0 500
         
  MAXSTEP
   {1}
  TIMESTEP
   {2}
  PRINT FORCES ON
  VDW CORRECTION ON
      
  ! -------- WANNIER ---------
       
  DIPOLE DYNAMICS WANNIER SAMPLE
   1
      
  ! SD,JACOBI,SVD
   WANNIER OPTIMIZATION JACOBI
         
         ! W STEP, W EPS, W RAN, W MAXS
         WANNIER PARAMETER
         0.1 1e-7 0.0 2000
  &END
         
  &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
         SYMMETRY
         1
         ANGSTROM
         CELL
         {3:.10f} 1.0 1.0  0.0  0.0  0.0

         CUTOFF
          70.0
  &END
         
  &DFT
         FUNCTIONAL BLYP
  &END
         
  &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
  &END

         &ATOMS
         '''.format("", max_step,timestep,self.cell_parameter)

          filename_bomd="bomd-wan-restart.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_bomd_wan_restart)
          # 最終的な出力を作成．
          if type == "default":
               self.write_coordinates(f_bomd) # 座標を出力
          if type == "sorted":
               self.write_coordinates_type2(f_bomd) # 座標を出力
     
          f_bomd.write("&END \n")
          f_bomd.close()
          
          # 次に，ACCUMULATORSだけ追加されたbomd_wan_restart2.inpを作成する．
          # 
          lines_bomd_wan_restart2='''
 &INFO
  input generated by dieltools :: restart calculation :: bomd+wf calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS BO
  MIRROR
  ! NOSEP restart nose ions thermostat
  RESTART WAVEFUNCTION COORDINATES VELOCITIES LATEST NOSEP {0}
        
  TRAJECTORY XYZ FORCES SAMPLE
     1
     
  FILEPATH
   ./tmp
         
  ! if you use berendsen thermostat,
  ! berendsen ions, 300.0 10000
  NOSE IONS MASSIVE
   300.0D0 500
         
  MAXSTEP
   {1}
  TIMESTEP
   {2}
  PRINT FORCES ON
  VDW CORRECTION ON
      
  ! -------- WANNIER ---------
       
  DIPOLE DYNAMICS WANNIER SAMPLE
   1
      
  ! SD,JACOBI,SVD
   WANNIER OPTIMIZATION JACOBI
         
         ! W STEP, W EPS, W RAN, W MAXS
         WANNIER PARAMETER
         0.1 1e-7 0.0 2000
  &END
         
  &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
         SYMMETRY
         1
         ANGSTROM
         CELL
         {3:.10f} 1.0 1.0  0.0  0.0  0.0

         CUTOFF
          70.0
  &END
         
  &DFT
         FUNCTIONAL BLYP
  &END
         
  &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
  &END

         &ATOMS
         '''.format("ACCUMULATORS", max_step,timestep,self.cell_parameter)
          
          filename_bomd2="bomd-wan-restart2.inp"

          f_bomd=open(filename_bomd2,mode="w")
          f_bomd.write(lines_bomd_wan_restart2)
          # 最終的な出力を作成．
          if type == "default":
               self.write_coordinates(f_bomd) # 座標を出力
          elif type == "sorted":
               self.write_coordinates_type2(f_bomd) # 座標を出力
          else:
               print("ERROR :: type is unknown !!")
     
          f_bomd.write("&END \n")
          f_bomd.close()
          
          return 0

     def make_bomd_oneshot(self,type="default"):
          '''
          入力座標に対してワンショットの計算．wannierの収集も実行する．
          2023/6/2：ワンショット計算の場合に，収束条件（RATTLE）を厳しくする．
          '''
          
          lines_bomd_oneshot='''
 &INFO
  input generated by dieltools :: bomd+wf oneshot calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS BO
  MIRROR
  TRAJECTORY XYZ FORCES SAMPLE
   1
     
  FILEPATH
   ./tmp
         
  BERENDSEN IONS
   300.0D0 10000
         
  MAXSTEP
   1
  TIMESTEP
   40
  PRINT FORCES ON
  RATTLE
   100 1e-7
  VDW CORRECTION ON
      
  ! -------- WANNIER ---------
       
  DIPOLE DYNAMICS WANNIER SAMPLE
   1
      
  ! SD,JACOBI,SVD
   WANNIER OPTIMIZATION JACOBI
         
  ! W STEP, W EPS, W RAN, W MAXS
   WANNIER PARAMETER
         0.1 1e-7 0.0 2000
  &END
         
  &SYSTEM
  !! type of symmetry
  !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
  SYMMETRY
         1
  ANGSTROM
  CELL
         {0:.10f} 1.0 1.0  0.0  0.0  0.0

  CUTOFF
         70.0
  &END
         
  &DFT
         FUNCTIONAL BLYP
  &END
         
  &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
  &END

  &ATOMS
         '''.format(self.cell_parameter)

          filename_bomd="bomd-oneshot.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_bomd_oneshot)
          # 最終的な出力を作成．
          if type == "default":
               self.write_coordinates(f_bomd) # 座標を出力
          if type == "sorted":
               self.write_coordinates_type2(f_bomd) # 座標を出力
     
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0

     
     
     def make_cpmd_wan(self,max_step:float=10000,type="default"):
          '''
          bomdではなくcpmd用の計算．
          wannierの収集を行う．
          CP計算なのでtimestepは4.a.uで固定．
          wannierのサンプルは10ステップごと，つまり40au.~1fsごとに行う．
          '''

          lines_cpmd_wan='''
 &INFO
  input generated by dieltools :: cpmd+wf calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS CP
  RESTART WAVEFUNCTION COORDINATES LATEST
        
  MIRROR
  TRAJECTORY XYZ FORCES SAMPLE
   5
     
  FILEPATH
   ./tmp
         
  TEMPERATURE
   300.0D0
         
  BERENDSEN IONS
   300.0D0 10000
         
  MAXSTEP
   {0}
  TIMESTEP
   4.0
  PRINT FORCES ON
  RATTLE
   100 1e-6
  VDW CORRECTION ON
      
  ! -------- WANNIER ---------
       
  DIPOLE DYNAMICS WANNIER SAMPLE
   10
      
  ! SD,JACOBI,SVD
   WANNIER OPTIMIZATION JACOBI
         
  ! W STEP, W EPS, W RAN, W MAXS
   WANNIER PARAMETER
         0.1 1e-7 0.0 2000
   &END
         
   &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
   SYMMETRY
         1
   ANGSTROM
   CELL
         {1:.10f} 1.0 1.0  0.0  0.0  0.0

   CUTOFF
         70.0
   &END
         
   &DFT
         FUNCTIONAL BLYP
   &END
         
   &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
  &END

         &ATOMS
         '''.format(max_step,self.cell_parameter)


          filename_bomd="cpmd-wan.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_cpmd_wan)
          if type=="default":
               self.write_coordinates(f_bomd) # 座標を出力
          if type=="sort":
               self.write_coordinates_type2(f_bomd) # 座標を出力
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0

     def make_cpmd(self,max_step:float=100000,type:str="default",emass:float=300):
          """_summary_
          bomdではなくcpmd用の計算．
          wannierの収集を行なわない．
          CP計算なのでtimestepは4.a.uで固定．
          cpmdのrestart計算なので，以下の量を引き継ぐ．
          - 前のrelax計算のNOSEP
          - relax計算のvelocity
          
          
          Args:
              max_step (float, optional): _description_. Defaults to 100000.
              type (str, optional): _description_. Defaults to "default".
          """


          lines_cpmd='''
 &INFO
  input generated by dieltools :: cpmd calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS CP
  RESTART WAVEFUNCTION COORDINATES VELOCITIES LATEST NOSEP {0}
        
  MIRROR
  TRAJECTORY XYZ FORCES SAMPLE
   5
     
  FILEPATH
   ./tmp
         
  !TEMPERATURE
  ! 300.0D0
         
  ! if you use berendsen thermostat,
  ! berendsen ions, 
  NOSE IONS MASSIVE
   300.0D0 500
         
  MAXSTEP
   {1}
  TIMESTEP
   4.0
  EMASS
   {2}
  PRINT FORCES ON
  !RATTLE
  ! 100 1e-6
  VDW CORRECTION ON      
   &END
         
   &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
   SYMMETRY
         1
   ANGSTROM
   CELL
         {3:.10f} 1.0 1.0  0.0  0.0  0.0

   CUTOFF
         70.0
   &END
         
   &DFT
         FUNCTIONAL BLYP
   &END
         
   &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
  &END

         &ATOMS
         '''.format("",max_step,emass,self.cell_parameter)


          filename_bomd="cpmd-restart.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_cpmd)
          if type=="default":
               self.write_coordinates(f_bomd) # 座標を出力
          elif type=="sorted":
               self.write_coordinates_type2(f_bomd) # 座標を出力
          else:
               print("make_cpmd:: ERROR:: not supported type.")
               
          f_bomd.write("&END \n")
          f_bomd.close()
          
          lines_cpmd_accumulator='''
 &INFO
  input generated by dieltools :: cpmd calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS CP
  RESTART WAVEFUNCTION COORDINATES VELOCITIES LATEST NOSEP {0}
        
  MIRROR
  TRAJECTORY XYZ FORCES SAMPLE
   5
     
  FILEPATH
   ./tmp
         
  ! TEMPERATURE
  ! 300.0D0
         
  ! if you use berendsen thermostat
  ! berendsen ions, 
  NOSE IONS MASSIVE
   300.0D0 500
         
  MAXSTEP
   {1}
  TIMESTEP
   4.0
  EMASS
   {2}
  PRINT FORCES ON
  !RATTLE
  ! 100 1e-6
  VDW CORRECTION ON      
   &END
         
   &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
   SYMMETRY
         1
   ANGSTROM
   CELL
         {3:.10f} 1.0 1.0  0.0  0.0  0.0

   CUTOFF
         70.0
   &END
         
   &DFT
         FUNCTIONAL BLYP
   &END
         
   &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
  &END

         &ATOMS
         '''.format("ACCUMULATORS",max_step,emass,self.cell_parameter)
         
          filename_bomd="cpmd-restart2.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_cpmd_accumulator)
          if type=="default":
               self.write_coordinates(f_bomd) # 座標を出力
          elif type=="sorted":
               self.write_coordinates_type2(f_bomd) # 座標を出力
          else:
               print("ERROR :: type is unknown !! default or sorted")
          f_bomd.write("&END \n")
          f_bomd.close()
          
          return 0

     
     def make_cpmd_relax(self,type:str="default",emass:float=300):
          '''
          bomdではなくcpmd用の計算．
          wannierの収集を行なわない．
          CP計算なのでtimestepは4.a.uで固定．
          '''

          lines_cpmd='''
 &INFO
  input generated by dieltools :: cpmd calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS CP
  MIRROR
  RESTART WAVEFUNCTION COORDINATES LATEST
  
  ! In CPMD, dt=4.a.u., and if we set SAMPLE=5, xyz contains every 20.a.u.(0.5fs)
  TRAJECTORY XYZ FORCES SAMPLE
     5
     
  FILEPATH
   ./tmp
         
  ! Initial temperature
  TEMPERATURE
   300.0D0
  
  ! TODO, for CPMD, alocate NOSE ELECTRONS
  ! if you use berendsen thermostat,
  ! berendsen ions, 
  NOSE IONS MASSIVE
   300.0D0 500
         
  MAXSTEP
   30000
  TIMESTEP
   4.0
  EMASS
   {0}
  PRINT FORCES ON
  !RATTLE
  ! 100 1e-6
  VDW CORRECTION ON      
   &END
         
   &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
   SYMMETRY
         1
   ANGSTROM
   CELL
         {1:.10f} 1.0 1.0  0.0  0.0  0.0

   CUTOFF
         70.0
   &END
         
   &DFT
         FUNCTIONAL BLYP
   &END
         
   &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
  &END

         &ATOMS
         '''.format(emass, self.cell_parameter)


          filename_bomd="cpmd-relax.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_cpmd)
          if type=="default":
               self.write_coordinates(f_bomd) # 座標を出力
          if type=="sorted":
               self.write_coordinates_type2(f_bomd) # 座標を出力
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0


     
     def write_coordinates(self,file):
          # 座標部分の出力を行う．
          ase_atoms_position=self.ase_atoms.get_positions()
          pre_index=""
          for i,index in enumerate(self.ase_atoms.get_chemical_symbols()):
               if index != pre_index: # 前の原子種と違ったらpseudo potential 情報を出力．
                    file.write("\n")
                    file.write("*pseudo/{0} KLEINMAN-BYLANDER \n".format(self.pseudo[index]))
                    if index == "H": # Hの場合
                         file.write("   LMAX=S \n")
                    else:
                         file.write("   LMAX=P \n")                         
                    file.write("   {0} \n".format(self.new_index[i]))
               file.write( " {0:.10f} {1:.10f} {2:.10f} \n".format(ase_atoms_position[i][0],ase_atoms_position[i][1],ase_atoms_position[i][2]))
               pre_index = index
          return 0

     def write_coordinates_type2(self,file):
          '''
          CPMDのTOO MANY SPIECES対策として，順番を並び替えて座標部分の入力ファイルを作成する．
          この時，同時に並べ替えのindexも取得して，別途テキストファイルに保存する．
          type2では，原子種を並び替えると同時に，並び替えのindexを格納したファイルを返す．
          大きな系だと，type1の入力に対してTOO MANY ATOMIC SPECIES SPECIFIEDというエラーが出てくる場合がある．
          そのような場合にはtype2を用いる．
          TODO :: IONS+CENTERS.xyzに対する後処理コードも準備する予定．
          '''
          import numpy as np
          # 座標取得
          ase_atoms_position=self.ase_atoms.get_positions()
          # 原子種を取得
          ase_atoms_symbol=self.ase_atoms.get_chemical_symbols()
          
          # 座標の並び替え
          # まず，原子種と座標を持ったリストanswerを作成
          answer=[]
          for i in range(len(ase_atoms_symbol)):
               answer.append([ase_atoms_symbol[i], ase_atoms_position[i][0],ase_atoms_position[i][1],ase_atoms_position[i][2] ])

          # 後で機械学習をするために配列のインデックスを取得して，逆変換を行えるようにする．
          # sortedでは，ソートするkeyが同じ値だった場合，他の最初の要素の順序を保つようにソートする（stableという性質らしい．https://docs.python.org/ja/3/howto/sorting.html 参照．）
          # そこで，answerの後ろにインデックス用の番号を降るようにする．

          # ソート用のリストを作成
          list=np.arange(len(answer)) #0から始まる配列
          list_for_sort=[[i[0],i[1],i[2],i[3],j] for i,j in zip(answer,list)]
          # ソートした順番に関するindex
          sort_index=[int(i[4]) for i in sorted(list_for_sort, key=lambda x:x[0])]
          sorted_atom=[[i[0],i[1],i[2],i[3]] for i in sorted(list_for_sort, key=lambda x:x[0])]
          # print(" ソートした順番に関するインデックス")
          # print(sort_index)
          print(" write_coordinates_type2 :: data is saved to sort_index.txt (needed for post process)")
          np.savetxt("sort_index.txt",np.array(sort_index,dtype='int64'))

          # 原子の要素を取り出す（setで重複を削除）
          atoms_symbol=sorted(set(ase_atoms_symbol))

          # シンボルごとのカウントをnum_atomに収納
          num_atom = {}
          for symbol in atoms_symbol:
               num_atom[symbol] = ase_atoms_symbol.count(symbol)
          print("")
          print("Atom :: species and numbers :: ", num_atom)
          print("")

          pre_index="" #最初のindex
          for i, ans in enumerate(sorted_atom):
               if pre_index != ans[0]: # 前の原子種と今の原子種が違う場合
                    file.write("\n")
                    file.write("*pseudo/{0} KLEINMAN-BYLANDER \n".format(self.pseudo[ans[0]]))
                    if ans[0] == "H": # Hの場合はLMAX=Sとする．
                         file.write("   LMAX=S \n")
                    else:
                         file.write("   LMAX=P \n")  
                    file.write("   {0} \n".format(num_atom[ans[0]]))                              
               file.write("{0:.10f}  {1:.10f}  {2:.10f} \n".format(ans[1],ans[2],ans[3]))

               # 一つ前の原子を保存
               pre_index = ans[0]
                               
          return 0
          

def back_convert_cpmd(input="IONS+CENTERS.xyz",output="IONS+CENTERS_sorted.xyz",sortfile="sort_index.txt"):
     """_summary_

     sort_index.txtをもとに，IONS+CENTERS.xyzの原子種の部分を並び替える．
     並び替えたあとのIONS+CENTERS.xyzをIONS+CENTERS_sorted.xyzとして保存する．
     このとき，わざわざsupercell情報は付与しなくてよいと思う．
     それは既存の別の関数に任せることにする．

     output
     --------------
     sortしたase.atomsをreturnする．
     
     Args:
         input (str, optional): _description_. Defaults to "IONS+CENTERS.xyz".
         output (str, optional): _description_. Defaults to "IONS+CENTERS_sorted.xyz".
         sortfile (str, optional): _description_. Defaults to "sort_index.txt".

     Returns:
         _type_: _description_
     """

     import ase
     import ase.io
     import numpy as np
     # 必要ファイルのload
     original_xyz=ase.io.read(input,index=":")
     sort_index=np.loadtxt(sortfile)

     # output
     sorted_ase_atoms_list=[]
     
     #
     for config_num, ase_atom in enumerate(original_xyz):
          # WCsの部分(X)とそれ以外に分割
          atom_list_ion= []
          atom_list_wc= []
          coord_list_ion= []
          coord_list_wc= []
          for coord,symbol in zip(ase_atom.get_positions(),ase_atom.get_chemical_symbols()):
               (atom_list_wc if symbol == "X" else atom_list_ion).append(symbol)
               (coord_list_wc if symbol == "X" else coord_list_ion).append(coord)

          # * ionの部分はsort_index.txtに従って並び替える．
          # sort_indexとリストを結合
          atom_list = [[i,j] for i,j in zip(sort_index,atom_list_ion)]
          coord_list = [[i,j] for i,j in zip(sort_index,coord_list_ion)]

          # sort_indexに従って配列を並べ直す
          sorted_atom_list = [i[1] for i in sorted(atom_list, key=lambda x:x[0])]
          sorted_coord_list = [i[1] for i in sorted(coord_list, key=lambda x:x[0])]

          # WCsと結合
          sorted_atom_list.extend(atom_list_wc)
          sorted_coord_list.extend(coord_list_wc)
          
          # ase.atomsにしてappend
          cell = ase_atom.get_cell() # もしセル情報がない場合でもこのままで大丈夫！！
          # print(f"cell {cell}")
          sorted_ase_atom = ase.Atoms(sorted_atom_list,
                                      positions=sorted_coord_list,
                                      cell = cell)
          sorted_ase_atoms_list.append(sorted_ase_atom)
     #
     # * 保存
     ase.io.write(output,sorted_ase_atoms_list)
     print(" ")
     print(" original xyz :: {}".format(input))
     print(" sort file :: {}".format(sortfile))
     print(" sorted xyz is saved to {} .\n".format(output))
     print(" ")
     return sorted_ase_atoms_list

     
     
     
