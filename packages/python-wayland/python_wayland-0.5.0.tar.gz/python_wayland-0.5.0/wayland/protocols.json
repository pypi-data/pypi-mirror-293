{
 "wl_display": {
  "events": [
   {
    "name": "error",
    "args": [
     {
      "name": "object_id",
      "type": "object"
     },
     {
      "name": "code",
      "type": "uint"
     },
     {
      "name": "message",
      "type": "string"
     }
    ],
    "opcode": 0
   },
   {
    "name": "delete_id",
    "args": [
     {
      "name": "id",
      "type": "uint"
     }
    ],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "sync",
    "args": [
     {
      "name": "callback",
      "type": "new_id",
      "interface": "wl_callback"
     }
    ],
    "opcode": 0
   },
   {
    "name": "get_registry",
    "args": [
     {
      "name": "registry",
      "type": "new_id",
      "interface": "wl_registry"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "core global object\n\nThe core global object.  This is a special singleton object.  It\nis used for internal Wayland protocol features.\n"
 },
 "wl_registry": {
  "events": [
   {
    "name": "global_",
    "args": [
     {
      "name": "name",
      "type": "uint"
     },
     {
      "name": "interface",
      "type": "string"
     },
     {
      "name": "version",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "global_remove",
    "args": [
     {
      "name": "name",
      "type": "uint"
     }
    ],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "bind",
    "args": [
     {
      "name": "name",
      "type": "uint"
     },
     {
      "name": "interface",
      "type": "string"
     },
     {
      "name": "version",
      "type": "uint"
     },
     {
      "name": "id",
      "type": "new_id"
     }
    ],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "global registry object\n\nThe singleton global registry object.  The server has a number of\nglobal objects that are available to all clients.  These objects\ntypically represent an actual object in the server (for example,\nan input device) or they are singleton objects that provide\nextension functionality.\n\nWhen a client creates a registry object, the registry object\nwill emit a global event for each global currently in the\nregistry.  Globals come and go as a result of device or\nmonitor hotplugs, reconfiguration or other events, and the\nregistry will send out global and global_remove events to\nkeep the client up to date with the changes.  To mark the end\nof the initial burst of events, the client can use the\nwl_display.sync request immediately after calling\nwl_display.get_registry.\n\nA client can bind to a global object by using the bind\nrequest.  This creates a client-side handle that lets the object\nemit events to the client and lets the client invoke requests on\nthe object.\n"
 },
 "wl_compositor": {
  "events": [],
  "methods": [
   {
    "name": "create_surface",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_surface"
     }
    ],
    "opcode": 0
   },
   {
    "name": "create_region",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_region"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "6",
  "description": "the compositor singleton\n\nA compositor.  This object is a singleton global.  The\ncompositor is in charge of combining the contents of multiple\nsurfaces into one displayable output.\n"
 },
 "wl_shm_pool": {
  "events": [],
  "methods": [
   {
    "name": "create_buffer",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_buffer"
     },
     {
      "name": "offset",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     },
     {
      "name": "stride",
      "type": "int"
     },
     {
      "name": "format",
      "type": "uint",
      "enum": "wl_shm.format"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   },
   {
    "name": "resize",
    "args": [
     {
      "name": "size",
      "type": "int"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "2",
  "description": "a shared memory pool\n\nThe wl_shm_pool object encapsulates a piece of memory shared\nbetween the compositor and client.  Through the wl_shm_pool\nobject, the client can allocate shared memory wl_buffer objects.\nAll objects created through the same pool share the same\nunderlying mapped memory. Reusing the mapped memory avoids the\nsetup/teardown overhead and is useful when interactively resizing\na surface or for many small buffers.\n"
 },
 "wl_shm": {
  "events": [
   {
    "name": "format",
    "args": [
     {
      "name": "format",
      "type": "uint",
      "enum": "format"
     }
    ],
    "opcode": 0
   }
  ],
  "methods": [
   {
    "name": "create_pool",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_shm_pool"
     },
     {
      "name": "fd",
      "type": "fd"
     },
     {
      "name": "size",
      "type": "int"
     }
    ],
    "opcode": 0
   },
   {
    "name": "release",
    "type": "destructor",
    "since": "2",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "2",
  "description": "shared memory support\n\nA singleton global object that provides support for shared\nmemory.\n\nClients can create wl_shm_pool objects using the create_pool\nrequest.\n\nOn binding the wl_shm object one or more format events\nare emitted to inform clients about the valid pixel formats\nthat can be used for buffers.\n"
 },
 "wl_buffer": {
  "events": [
   {
    "name": "release",
    "args": [],
    "opcode": 0
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "content for a wl_surface\n\nA buffer provides the content for a wl_surface. Buffers are\ncreated through factory interfaces such as wl_shm, wp_linux_buffer_params\n(from the linux-dmabuf protocol extension) or similar. It has a width and\na height and can be attached to a wl_surface, but the mechanism by which a\nclient provides and updates the contents is defined by the buffer factory\ninterface.\n\nColor channels are assumed to be electrical rather than optical (in other\nwords, encoded with a transfer function) unless otherwise specified. If\nthe buffer uses a format that has an alpha channel, the alpha channel is\nassumed to be premultiplied into the electrical color channel values\n(after transfer function encoding) unless otherwise specified.\n\nNote, because wl_buffer objects are created from multiple independent\nfactory interfaces, the wl_buffer interface is frozen at version 1.\n"
 },
 "wl_data_offer": {
  "events": [
   {
    "name": "offer",
    "args": [
     {
      "name": "mime_type",
      "type": "string"
     }
    ],
    "opcode": 0
   },
   {
    "name": "source_actions",
    "since": "3",
    "args": [
     {
      "name": "source_actions",
      "type": "uint",
      "enum": "wl_data_device_manager.dnd_action"
     }
    ],
    "opcode": 1
   },
   {
    "name": "action",
    "since": "3",
    "args": [
     {
      "name": "dnd_action",
      "type": "uint",
      "enum": "wl_data_device_manager.dnd_action"
     }
    ],
    "opcode": 2
   }
  ],
  "methods": [
   {
    "name": "accept",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "mime_type",
      "type": "string",
      "allow-null": "true"
     }
    ],
    "opcode": 0
   },
   {
    "name": "receive",
    "args": [
     {
      "name": "mime_type",
      "type": "string"
     },
     {
      "name": "fd",
      "type": "fd"
     }
    ],
    "opcode": 1
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 2
   },
   {
    "name": "finish",
    "since": "3",
    "args": [],
    "opcode": 3
   },
   {
    "name": "set_actions",
    "since": "3",
    "args": [
     {
      "name": "dnd_actions",
      "type": "uint",
      "enum": "wl_data_device_manager.dnd_action"
     },
     {
      "name": "preferred_action",
      "type": "uint",
      "enum": "wl_data_device_manager.dnd_action"
     }
    ],
    "opcode": 4
   }
  ],
  "version": "3",
  "description": "offer to transfer data\n\nA wl_data_offer represents a piece of data offered for transfer\nby another client (the source client).  It is used by the\ncopy-and-paste and drag-and-drop mechanisms.  The offer\ndescribes the different mime types that the data can be\nconverted to and provides the mechanism for transferring the\ndata directly from the source client.\n"
 },
 "wl_data_source": {
  "events": [
   {
    "name": "target",
    "args": [
     {
      "name": "mime_type",
      "type": "string",
      "allow-null": "true"
     }
    ],
    "opcode": 0
   },
   {
    "name": "send",
    "args": [
     {
      "name": "mime_type",
      "type": "string"
     },
     {
      "name": "fd",
      "type": "fd"
     }
    ],
    "opcode": 1
   },
   {
    "name": "cancelled",
    "args": [],
    "opcode": 2
   },
   {
    "name": "dnd_drop_performed",
    "since": "3",
    "args": [],
    "opcode": 3
   },
   {
    "name": "dnd_finished",
    "since": "3",
    "args": [],
    "opcode": 4
   },
   {
    "name": "action",
    "since": "3",
    "args": [
     {
      "name": "dnd_action",
      "type": "uint",
      "enum": "wl_data_device_manager.dnd_action"
     }
    ],
    "opcode": 5
   }
  ],
  "methods": [
   {
    "name": "offer",
    "args": [
     {
      "name": "mime_type",
      "type": "string"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   },
   {
    "name": "set_actions",
    "since": "3",
    "args": [
     {
      "name": "dnd_actions",
      "type": "uint",
      "enum": "wl_data_device_manager.dnd_action"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "3",
  "description": "offer to transfer data\n\nThe wl_data_source object is the source side of a wl_data_offer.\nIt is created by the source client in a data transfer and\nprovides a way to describe the offered data and a way to respond\nto requests to transfer the data.\n"
 },
 "wl_data_device": {
  "events": [
   {
    "name": "data_offer",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_data_offer"
     }
    ],
    "opcode": 0
   },
   {
    "name": "enter",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "x",
      "type": "fixed"
     },
     {
      "name": "y",
      "type": "fixed"
     },
     {
      "name": "id",
      "type": "object",
      "interface": "wl_data_offer",
      "allow-null": "true"
     }
    ],
    "opcode": 1
   },
   {
    "name": "leave",
    "args": [],
    "opcode": 2
   },
   {
    "name": "motion",
    "args": [
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "x",
      "type": "fixed"
     },
     {
      "name": "y",
      "type": "fixed"
     }
    ],
    "opcode": 3
   },
   {
    "name": "drop",
    "args": [],
    "opcode": 4
   },
   {
    "name": "selection",
    "args": [
     {
      "name": "id",
      "type": "object",
      "interface": "wl_data_offer",
      "allow-null": "true"
     }
    ],
    "opcode": 5
   }
  ],
  "methods": [
   {
    "name": "start_drag",
    "args": [
     {
      "name": "source",
      "type": "object",
      "interface": "wl_data_source",
      "allow-null": "true"
     },
     {
      "name": "origin",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "icon",
      "type": "object",
      "interface": "wl_surface",
      "allow-null": "true"
     },
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "set_selection",
    "args": [
     {
      "name": "source",
      "type": "object",
      "interface": "wl_data_source",
      "allow-null": "true"
     },
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "release",
    "type": "destructor",
    "since": "2",
    "args": [],
    "opcode": 2
   }
  ],
  "version": "3",
  "description": "data transfer device\n\nThere is one wl_data_device per seat which can be obtained\nfrom the global wl_data_device_manager singleton.\n\nA wl_data_device provides access to inter-client data transfer\nmechanisms such as copy-and-paste and drag-and-drop.\n"
 },
 "wl_data_device_manager": {
  "events": [],
  "methods": [
   {
    "name": "create_data_source",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_data_source"
     }
    ],
    "opcode": 0
   },
   {
    "name": "get_data_device",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_data_device"
     },
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "3",
  "description": "data transfer interface\n\nThe wl_data_device_manager is a singleton global object that\nprovides access to inter-client data transfer mechanisms such as\ncopy-and-paste and drag-and-drop.  These mechanisms are tied to\na wl_seat and this interface lets a client get a wl_data_device\ncorresponding to a wl_seat.\n\nDepending on the version bound, the objects created from the bound\nwl_data_device_manager object will have different requirements for\nfunctioning properly. See wl_data_source.set_actions,\nwl_data_offer.accept and wl_data_offer.finish for details.\n"
 },
 "wl_shell": {
  "events": [],
  "methods": [
   {
    "name": "get_shell_surface",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_shell_surface"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "create desktop-style surfaces\n\nThis interface is implemented by servers that provide\ndesktop-style user interfaces.\n\nIt allows clients to associate a wl_shell_surface with\na basic surface.\n\nNote! This protocol is deprecated and not intended for production use.\nFor desktop-style user interfaces, use xdg_shell. Compositors and clients\nshould not implement this interface.\n"
 },
 "wl_shell_surface": {
  "events": [
   {
    "name": "ping",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "configure",
    "args": [
     {
      "name": "edges",
      "type": "uint",
      "enum": "resize"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 1
   },
   {
    "name": "popup_done",
    "args": [],
    "opcode": 2
   }
  ],
  "methods": [
   {
    "name": "pong",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "move",
    "args": [
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     },
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "resize",
    "args": [
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     },
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "edges",
      "type": "uint",
      "enum": "resize"
     }
    ],
    "opcode": 2
   },
   {
    "name": "set_toplevel",
    "args": [],
    "opcode": 3
   },
   {
    "name": "set_transient",
    "args": [
     {
      "name": "parent",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "flags",
      "type": "uint",
      "enum": "transient"
     }
    ],
    "opcode": 4
   },
   {
    "name": "set_fullscreen",
    "args": [
     {
      "name": "method",
      "type": "uint",
      "enum": "fullscreen_method"
     },
     {
      "name": "framerate",
      "type": "uint"
     },
     {
      "name": "output",
      "type": "object",
      "interface": "wl_output",
      "allow-null": "true"
     }
    ],
    "opcode": 5
   },
   {
    "name": "set_popup",
    "args": [
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     },
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "parent",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "flags",
      "type": "uint",
      "enum": "transient"
     }
    ],
    "opcode": 6
   },
   {
    "name": "set_maximized",
    "args": [
     {
      "name": "output",
      "type": "object",
      "interface": "wl_output",
      "allow-null": "true"
     }
    ],
    "opcode": 7
   },
   {
    "name": "set_title",
    "args": [
     {
      "name": "title",
      "type": "string"
     }
    ],
    "opcode": 8
   },
   {
    "name": "set_class",
    "args": [
     {
      "name": "class_",
      "type": "string"
     }
    ],
    "opcode": 9
   }
  ],
  "version": "1",
  "description": "desktop-style metadata interface\n\nAn interface that may be implemented by a wl_surface, for\nimplementations that provide a desktop-style user interface.\n\nIt provides requests to treat surfaces like toplevel, fullscreen\nor popup windows, move, resize or maximize them, associate\nmetadata like title and class, etc.\n\nOn the server side the object is automatically destroyed when\nthe related wl_surface is destroyed. On the client side,\nwl_shell_surface_destroy() must be called before destroying\nthe wl_surface object.\n"
 },
 "wl_surface": {
  "events": [
   {
    "name": "enter",
    "args": [
     {
      "name": "output",
      "type": "object",
      "interface": "wl_output"
     }
    ],
    "opcode": 0
   },
   {
    "name": "leave",
    "args": [
     {
      "name": "output",
      "type": "object",
      "interface": "wl_output"
     }
    ],
    "opcode": 1
   },
   {
    "name": "preferred_buffer_scale",
    "since": "6",
    "args": [
     {
      "name": "factor",
      "type": "int"
     }
    ],
    "opcode": 2
   },
   {
    "name": "preferred_buffer_transform",
    "since": "6",
    "args": [
     {
      "name": "transform",
      "type": "uint",
      "enum": "wl_output.transform"
     }
    ],
    "opcode": 3
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "attach",
    "args": [
     {
      "name": "buffer",
      "type": "object",
      "interface": "wl_buffer",
      "allow-null": "true"
     },
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     }
    ],
    "opcode": 1
   },
   {
    "name": "damage",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 2
   },
   {
    "name": "frame",
    "args": [
     {
      "name": "callback",
      "type": "new_id",
      "interface": "wl_callback"
     }
    ],
    "opcode": 3
   },
   {
    "name": "set_opaque_region",
    "args": [
     {
      "name": "region",
      "type": "object",
      "interface": "wl_region",
      "allow-null": "true"
     }
    ],
    "opcode": 4
   },
   {
    "name": "set_input_region",
    "args": [
     {
      "name": "region",
      "type": "object",
      "interface": "wl_region",
      "allow-null": "true"
     }
    ],
    "opcode": 5
   },
   {
    "name": "commit",
    "args": [],
    "opcode": 6
   },
   {
    "name": "set_buffer_transform",
    "since": "2",
    "args": [
     {
      "name": "transform",
      "type": "int",
      "enum": "wl_output.transform"
     }
    ],
    "opcode": 7
   },
   {
    "name": "set_buffer_scale",
    "since": "3",
    "args": [
     {
      "name": "scale",
      "type": "int"
     }
    ],
    "opcode": 8
   },
   {
    "name": "damage_buffer",
    "since": "4",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 9
   },
   {
    "name": "offset",
    "since": "5",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     }
    ],
    "opcode": 10
   }
  ],
  "version": "6",
  "description": "an onscreen surface\n\nA surface is a rectangular area that may be displayed on zero\nor more outputs, and shown any number of times at the compositor's\ndiscretion. They can present wl_buffers, receive user input, and\ndefine a local coordinate system.\n\nThe size of a surface (and relative positions on it) is described\nin surface-local coordinates, which may differ from the buffer\ncoordinates of the pixel content, in case a buffer_transform\nor a buffer_scale is used.\n\nA surface without a \"role\" is fairly useless: a compositor does\nnot know where, when or how to present it. The role is the\npurpose of a wl_surface. Examples of roles are a cursor for a\npointer (as set by wl_pointer.set_cursor), a drag icon\n(wl_data_device.start_drag), a sub-surface\n(wl_subcompositor.get_subsurface), and a window as defined by a\nshell protocol (e.g. wl_shell.get_shell_surface).\n\nA surface can have only one role at a time. Initially a\nwl_surface does not have a role. Once a wl_surface is given a\nrole, it is set permanently for the whole lifetime of the\nwl_surface object. Giving the current role again is allowed,\nunless explicitly forbidden by the relevant interface\nspecification.\n\nSurface roles are given by requests in other interfaces such as\nwl_pointer.set_cursor. The request should explicitly mention\nthat this request gives a role to a wl_surface. Often, this\nrequest also creates a new protocol object that represents the\nrole and adds additional functionality to wl_surface. When a\nclient wants to destroy a wl_surface, they must destroy this role\nobject before the wl_surface, otherwise a defunct_role_object error is\nsent.\n\nDestroying the role object does not remove the role from the\nwl_surface, but it may stop the wl_surface from \"playing the role\".\nFor instance, if a wl_subsurface object is destroyed, the wl_surface\nit was created for will be unmapped and forget its position and\nz-order. It is allowed to create a wl_subsurface for the same\nwl_surface again, but it is not allowed to use the wl_surface as\na cursor (cursor is a different role than sub-surface, and role\nswitching is not allowed).\n"
 },
 "wl_seat": {
  "events": [
   {
    "name": "capabilities",
    "args": [
     {
      "name": "capabilities",
      "type": "uint",
      "enum": "capability"
     }
    ],
    "opcode": 0
   },
   {
    "name": "name",
    "since": "2",
    "args": [
     {
      "name": "name",
      "type": "string"
     }
    ],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "get_pointer",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_pointer"
     }
    ],
    "opcode": 0
   },
   {
    "name": "get_keyboard",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_keyboard"
     }
    ],
    "opcode": 1
   },
   {
    "name": "get_touch",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_touch"
     }
    ],
    "opcode": 2
   },
   {
    "name": "release",
    "type": "destructor",
    "since": "5",
    "args": [],
    "opcode": 3
   }
  ],
  "version": "9",
  "description": "group of input devices\n\nA seat is a group of keyboards, pointer and touch devices. This\nobject is published as a global during start up, or when such a\ndevice is hot plugged.  A seat typically has a pointer and\nmaintains a keyboard focus and a pointer focus.\n"
 },
 "wl_pointer": {
  "events": [
   {
    "name": "enter",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "surface_x",
      "type": "fixed"
     },
     {
      "name": "surface_y",
      "type": "fixed"
     }
    ],
    "opcode": 0
   },
   {
    "name": "leave",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   },
   {
    "name": "motion",
    "args": [
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "surface_x",
      "type": "fixed"
     },
     {
      "name": "surface_y",
      "type": "fixed"
     }
    ],
    "opcode": 2
   },
   {
    "name": "button",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "button",
      "type": "uint"
     },
     {
      "name": "state",
      "type": "uint",
      "enum": "button_state"
     }
    ],
    "opcode": 3
   },
   {
    "name": "axis",
    "args": [
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "axis",
      "type": "uint",
      "enum": "axis"
     },
     {
      "name": "value",
      "type": "fixed"
     }
    ],
    "opcode": 4
   },
   {
    "name": "frame",
    "since": "5",
    "args": [],
    "opcode": 5
   },
   {
    "name": "axis_source",
    "since": "5",
    "args": [
     {
      "name": "axis_source",
      "type": "uint",
      "enum": "axis_source"
     }
    ],
    "opcode": 6
   },
   {
    "name": "axis_stop",
    "since": "5",
    "args": [
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "axis",
      "type": "uint",
      "enum": "axis"
     }
    ],
    "opcode": 7
   },
   {
    "name": "axis_discrete",
    "since": "5",
    "deprecated-since": "8",
    "args": [
     {
      "name": "axis",
      "type": "uint",
      "enum": "axis"
     },
     {
      "name": "discrete",
      "type": "int"
     }
    ],
    "opcode": 8
   },
   {
    "name": "axis_value120",
    "since": "8",
    "args": [
     {
      "name": "axis",
      "type": "uint",
      "enum": "axis"
     },
     {
      "name": "value120",
      "type": "int"
     }
    ],
    "opcode": 9
   },
   {
    "name": "axis_relative_direction",
    "since": "9",
    "args": [
     {
      "name": "axis",
      "type": "uint",
      "enum": "axis"
     },
     {
      "name": "direction",
      "type": "uint",
      "enum": "axis_relative_direction"
     }
    ],
    "opcode": 10
   }
  ],
  "methods": [
   {
    "name": "set_cursor",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface",
      "allow-null": "true"
     },
     {
      "name": "hotspot_x",
      "type": "int"
     },
     {
      "name": "hotspot_y",
      "type": "int"
     }
    ],
    "opcode": 0
   },
   {
    "name": "release",
    "type": "destructor",
    "since": "3",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "9",
  "description": "pointer input device\n\nThe wl_pointer interface represents one or more input devices,\nsuch as mice, which control the pointer location and pointer_focus\nof a seat.\n\nThe wl_pointer interface generates motion, enter and leave\nevents for the surfaces that the pointer is located over,\nand button and axis events for button presses, button releases\nand scrolling.\n"
 },
 "wl_keyboard": {
  "events": [
   {
    "name": "keymap",
    "args": [
     {
      "name": "format",
      "type": "uint",
      "enum": "keymap_format"
     },
     {
      "name": "fd",
      "type": "fd"
     },
     {
      "name": "size",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "enter",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "keys",
      "type": "array"
     }
    ],
    "opcode": 1
   },
   {
    "name": "leave",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 2
   },
   {
    "name": "key",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "key",
      "type": "uint"
     },
     {
      "name": "state",
      "type": "uint",
      "enum": "key_state"
     }
    ],
    "opcode": 3
   },
   {
    "name": "modifiers",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "mods_depressed",
      "type": "uint"
     },
     {
      "name": "mods_latched",
      "type": "uint"
     },
     {
      "name": "mods_locked",
      "type": "uint"
     },
     {
      "name": "group",
      "type": "uint"
     }
    ],
    "opcode": 4
   },
   {
    "name": "repeat_info",
    "since": "4",
    "args": [
     {
      "name": "rate",
      "type": "int"
     },
     {
      "name": "delay",
      "type": "int"
     }
    ],
    "opcode": 5
   }
  ],
  "methods": [
   {
    "name": "release",
    "type": "destructor",
    "since": "3",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "9",
  "description": "keyboard input device\n\nThe wl_keyboard interface represents one or more keyboards\nassociated with a seat.\n\nEach wl_keyboard has the following logical state:\n\n- an active surface (possibly null),\n- the keys currently logically down,\n- the active modifiers,\n- the active group.\n\nBy default, the active surface is null, the keys currently logically down\nare empty, the active modifiers and the active group are 0.\n"
 },
 "wl_touch": {
  "events": [
   {
    "name": "down",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "id",
      "type": "int"
     },
     {
      "name": "x",
      "type": "fixed"
     },
     {
      "name": "y",
      "type": "fixed"
     }
    ],
    "opcode": 0
   },
   {
    "name": "up",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "id",
      "type": "int"
     }
    ],
    "opcode": 1
   },
   {
    "name": "motion",
    "args": [
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "id",
      "type": "int"
     },
     {
      "name": "x",
      "type": "fixed"
     },
     {
      "name": "y",
      "type": "fixed"
     }
    ],
    "opcode": 2
   },
   {
    "name": "frame",
    "args": [],
    "opcode": 3
   },
   {
    "name": "cancel",
    "args": [],
    "opcode": 4
   },
   {
    "name": "shape",
    "since": "6",
    "args": [
     {
      "name": "id",
      "type": "int"
     },
     {
      "name": "major",
      "type": "fixed"
     },
     {
      "name": "minor",
      "type": "fixed"
     }
    ],
    "opcode": 5
   },
   {
    "name": "orientation",
    "since": "6",
    "args": [
     {
      "name": "id",
      "type": "int"
     },
     {
      "name": "orientation",
      "type": "fixed"
     }
    ],
    "opcode": 6
   }
  ],
  "methods": [
   {
    "name": "release",
    "type": "destructor",
    "since": "3",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "9",
  "description": "touchscreen input device\n\nThe wl_touch interface represents a touchscreen\nassociated with a seat.\n\nTouch interactions can consist of one or more contacts.\nFor each contact, a series of events is generated, starting\nwith a down event, followed by zero or more motion events,\nand ending with an up event. Events relating to the same\ncontact point can be identified by the ID of the sequence.\n"
 },
 "wl_output": {
  "events": [
   {
    "name": "geometry",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "physical_width",
      "type": "int"
     },
     {
      "name": "physical_height",
      "type": "int"
     },
     {
      "name": "subpixel",
      "type": "int",
      "enum": "subpixel"
     },
     {
      "name": "make",
      "type": "string"
     },
     {
      "name": "model",
      "type": "string"
     },
     {
      "name": "transform",
      "type": "int",
      "enum": "transform"
     }
    ],
    "opcode": 0
   },
   {
    "name": "mode",
    "args": [
     {
      "name": "flags",
      "type": "uint",
      "enum": "mode"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     },
     {
      "name": "refresh",
      "type": "int"
     }
    ],
    "opcode": 1
   },
   {
    "name": "done",
    "since": "2",
    "args": [],
    "opcode": 2
   },
   {
    "name": "scale",
    "since": "2",
    "args": [
     {
      "name": "factor",
      "type": "int"
     }
    ],
    "opcode": 3
   },
   {
    "name": "name",
    "since": "4",
    "args": [
     {
      "name": "name",
      "type": "string"
     }
    ],
    "opcode": 4
   },
   {
    "name": "description",
    "since": "4",
    "args": [
     {
      "name": "description",
      "type": "string"
     }
    ],
    "opcode": 5
   }
  ],
  "methods": [
   {
    "name": "release",
    "type": "destructor",
    "since": "3",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "4",
  "description": "compositor output region\n\nAn output describes part of the compositor geometry.  The\ncompositor works in the 'compositor coordinate system' and an\noutput corresponds to a rectangular area in that space that is\nactually visible.  This typically corresponds to a monitor that\ndisplays part of the compositor space.  This object is published\nas global during start up, or when a monitor is hotplugged.\n"
 },
 "wl_region": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "add",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 1
   },
   {
    "name": "subtract",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "region interface\n\nA region object describes an area.\n\nRegion objects are used to describe the opaque and input\nregions of a surface.\n"
 },
 "wl_subcompositor": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_subsurface",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_subsurface"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "parent",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "sub-surface compositing\n\nThe global interface exposing sub-surface compositing capabilities.\nA wl_surface, that has sub-surfaces associated, is called the\nparent surface. Sub-surfaces can be arbitrarily nested and create\na tree of sub-surfaces.\n\nThe root surface in a tree of sub-surfaces is the main\nsurface. The main surface cannot be a sub-surface, because\nsub-surfaces must always have a parent.\n\nA main surface with its sub-surfaces forms a (compound) window.\nFor window management purposes, this set of wl_surface objects is\nto be considered as a single window, and it should also behave as\nsuch.\n\nThe aim of sub-surfaces is to offload some of the compositing work\nwithin a window from clients to the compositor. A prime example is\na video player with decorations and video in separate wl_surface\nobjects. This should allow the compositor to pass YUV video buffer\nprocessing to dedicated overlay hardware when possible.\n"
 },
 "wl_subsurface": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_position",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     }
    ],
    "opcode": 1
   },
   {
    "name": "place_above",
    "args": [
     {
      "name": "sibling",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 2
   },
   {
    "name": "place_below",
    "args": [
     {
      "name": "sibling",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 3
   },
   {
    "name": "set_sync",
    "args": [],
    "opcode": 4
   },
   {
    "name": "set_desync",
    "args": [],
    "opcode": 5
   }
  ],
  "version": "1",
  "description": "sub-surface interface to a wl_surface\n\nAn additional interface to a wl_surface object, which has been\nmade a sub-surface. A sub-surface has one parent surface. A\nsub-surface's size and position are not limited to that of the parent.\nParticularly, a sub-surface is not automatically clipped to its\nparent's area.\n\nA sub-surface becomes mapped, when a non-NULL wl_buffer is applied\nand the parent surface is mapped. The order of which one happens\nfirst is irrelevant. A sub-surface is hidden if the parent becomes\nhidden, or if a NULL wl_buffer is applied. These rules apply\nrecursively through the tree of surfaces.\n\nThe behaviour of a wl_surface.commit request on a sub-surface\ndepends on the sub-surface's mode. The possible modes are\nsynchronized and desynchronized, see methods\nwl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized\nmode caches the wl_surface state to be applied when the parent's\nstate gets applied, and desynchronized mode applies the pending\nwl_surface state directly. A sub-surface is initially in the\nsynchronized mode.\n\nSub-surfaces also have another kind of state, which is managed by\nwl_subsurface requests, as opposed to wl_surface requests. This\nstate includes the sub-surface position relative to the parent\nsurface (wl_subsurface.set_position), and the stacking order of\nthe parent and its sub-surfaces (wl_subsurface.place_above and\n.place_below). This state is applied when the parent surface's\nwl_surface state is applied, regardless of the sub-surface's mode.\nAs the exception, set_sync and set_desync are effective immediately.\n\nThe main surface can be thought to be always in desynchronized mode,\nsince it does not have a parent in the sub-surfaces sense.\n\nEven if a sub-surface is in desynchronized mode, it will behave as\nin synchronized mode, if its parent surface behaves as in\nsynchronized mode. This rule is applied recursively throughout the\ntree of surfaces. This means, that one can set a sub-surface into\nsynchronized mode, and then assume that all its child and grand-child\nsub-surfaces are synchronized, too, without explicitly setting them.\n\nDestroying a sub-surface takes effect immediately. If you need to\nsynchronize the removal of a sub-surface to the parent surface update,\nunmap the sub-surface first by attaching a NULL wl_buffer, update parent,\nand then destroy the sub-surface.\n\nIf the parent wl_surface object is destroyed, the sub-surface is\nunmapped.\n\nA sub-surface never has the keyboard focus of any seat.\n\nThe wl_surface.offset request is ignored: clients must use set_position\ninstead to move the sub-surface.\n"
 },
 "wl_callback": {
  "events": [
   {
    "name": "done",
    "type": "destructor",
    "args": [
     {
      "name": "callback_data",
      "type": "uint"
     }
    ],
    "opcode": 0
   }
  ],
  "methods": [],
  "version": "1",
  "description": "callback object\n\nClients can handle the 'done' event to get notified when\nthe related request is done.\n\nNote, because wl_callback objects are created from multiple independent\nfactory interfaces, the wl_callback interface is frozen at version 1.\n"
 },
 "wp_alpha_modifier_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_surface",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_alpha_modifier_surface_v1"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "surface alpha modifier manager\n\nThis interface allows a client to set a factor for the alpha values on a\nsurface, which can be used to offload such operations to the compositor,\nwhich can in turn for example offload them to KMS.\n\nWarning! The protocol described in this file is currently in the testing\nphase. Backward compatible changes may be added together with the\ncorresponding interface version bump. Backward incompatible changes can\nonly be done by creating a new major version of the extension.\n"
 },
 "wp_alpha_modifier_surface_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_multiplier",
    "args": [
     {
      "name": "factor",
      "type": "uint"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "alpha modifier object for a surface\n\nThis interface allows the client to set a factor for the alpha values on\na surface, which can be used to offload such operations to the compositor.\nThe default factor is UINT32_MAX.\n\nThis object has to be destroyed before the associated wl_surface. Once the\nwl_surface is destroyed, all request on this object will raise the\nno_surface error.\n"
 },
 "wp_content_type_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_surface_content_type",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_content_type_v1"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "surface content type manager\n\nThis interface allows a client to describe the kind of content a surface\nwill display, to allow the compositor to optimize its behavior for it.\n\nWarning! The protocol described in this file is currently in the testing\nphase. Backward compatible changes may be added together with the\ncorresponding interface version bump. Backward incompatible changes can\nonly be done by creating a new major version of the extension.\n"
 },
 "wp_content_type_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_content_type",
    "args": [
     {
      "name": "content_type",
      "type": "uint",
      "enum": "type"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "content type object for a surface\n\nThe content type object allows the compositor to optimize for the kind\nof content shown on the surface. A compositor may for example use it to\nset relevant drm properties like \"content type\".\n\nThe client may request to switch to another content type at any time.\nWhen the associated surface gets destroyed, this object becomes inert and\nthe client should destroy it.\n"
 },
 "wp_cursor_shape_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_pointer",
    "args": [
     {
      "name": "cursor_shape_device",
      "type": "new_id",
      "interface": "wp_cursor_shape_device_v1"
     },
     {
      "name": "pointer",
      "type": "object",
      "interface": "wl_pointer"
     }
    ],
    "opcode": 1
   },
   {
    "name": "get_tablet_tool_v2",
    "args": [
     {
      "name": "cursor_shape_device",
      "type": "new_id",
      "interface": "wp_cursor_shape_device_v1"
     },
     {
      "name": "tablet_tool",
      "type": "object",
      "interface": "zwp_tablet_tool_v2"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "cursor shape manager\n\nThis global offers an alternative, optional way to set cursor images. This\nnew way uses enumerated cursors instead of a wl_surface like\nwl_pointer.set_cursor does.\n\nWarning! The protocol described in this file is currently in the testing\nphase. Backward compatible changes may be added together with the\ncorresponding interface version bump. Backward incompatible changes can\nonly be done by creating a new major version of the extension.\n"
 },
 "wp_cursor_shape_device_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_shape",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "shape",
      "type": "uint",
      "enum": "shape"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "cursor shape for a device\n\nThis interface allows clients to set the cursor shape.\n"
 },
 "wp_drm_lease_device_v1": {
  "events": [
   {
    "name": "drm_fd",
    "args": [
     {
      "name": "fd",
      "type": "fd"
     }
    ],
    "opcode": 0
   },
   {
    "name": "connector",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_drm_lease_connector_v1"
     }
    ],
    "opcode": 1
   },
   {
    "name": "done",
    "args": [],
    "opcode": 2
   },
   {
    "name": "released",
    "type": "destructor",
    "args": [],
    "opcode": 3
   }
  ],
  "methods": [
   {
    "name": "create_lease_request",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_drm_lease_request_v1"
     }
    ],
    "opcode": 0
   },
   {
    "name": "release",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "lease device\n\nThis protocol is used by Wayland compositors which act as Direct\nRendering Manager (DRM) masters to lease DRM resources to Wayland\nclients.\n\nThe compositor will advertise one wp_drm_lease_device_v1 global for each\nDRM node. Some time after a client binds to the wp_drm_lease_device_v1\nglobal, the compositor will send a drm_fd event followed by zero, one or\nmore connector events. After all currently available connectors have been\nsent, the compositor will send a wp_drm_lease_device_v1.done event.\n\nWhen the list of connectors available for lease changes the compositor\nwill send wp_drm_lease_device_v1.connector events for added connectors and\nwp_drm_lease_connector_v1.withdrawn events for removed connectors,\nfollowed by a wp_drm_lease_device_v1.done event.\n\nThe compositor will indicate when a device is gone by removing the global\nvia a wl_registry.global_remove event. Upon receiving this event, the\nclient should destroy any matching wp_drm_lease_device_v1 object.\n\nTo destroy a wp_drm_lease_device_v1 object, the client must first issue\na release request. Upon receiving this request, the compositor will\nimmediately send a released event and destroy the object. The client must\ncontinue to process and discard drm_fd and connector events until it\nreceives the released event. Upon receiving the released event, the\nclient can safely cleanup any client-side resources.\n\nWarning! The protocol described in this file is currently in the testing\nphase. Backward compatible changes may be added together with the\ncorresponding interface version bump. Backward incompatible changes can\nonly be done by creating a new major version of the extension.\n"
 },
 "wp_drm_lease_connector_v1": {
  "events": [
   {
    "name": "name",
    "args": [
     {
      "name": "name",
      "type": "string"
     }
    ],
    "opcode": 0
   },
   {
    "name": "description",
    "args": [
     {
      "name": "description",
      "type": "string"
     }
    ],
    "opcode": 1
   },
   {
    "name": "connector_id",
    "args": [
     {
      "name": "connector_id",
      "type": "uint"
     }
    ],
    "opcode": 2
   },
   {
    "name": "done",
    "args": [],
    "opcode": 3
   },
   {
    "name": "withdrawn",
    "args": [],
    "opcode": 4
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "a leasable DRM connector\n\nRepresents a DRM connector which is available for lease. These objects are\ncreated via wp_drm_lease_device_v1.connector events, and should be passed\nto lease requests via wp_drm_lease_request_v1.request_connector.\nImmediately after the wp_drm_lease_connector_v1 object is created the\ncompositor will send a name, a description, a connector_id and a done\nevent. When the description is updated the compositor will send a\ndescription event followed by a done event.\n"
 },
 "wp_drm_lease_request_v1": {
  "events": [],
  "methods": [
   {
    "name": "request_connector",
    "args": [
     {
      "name": "connector",
      "type": "object",
      "interface": "wp_drm_lease_connector_v1"
     }
    ],
    "opcode": 0
   },
   {
    "name": "submit",
    "type": "destructor",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_drm_lease_v1"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "DRM lease request\n\nA client that wishes to lease DRM resources will attach the list of\nconnectors advertised with wp_drm_lease_device_v1.connector that they\nwish to lease, then use wp_drm_lease_request_v1.submit to submit the\nrequest.\n"
 },
 "wp_drm_lease_v1": {
  "events": [
   {
    "name": "lease_fd",
    "args": [
     {
      "name": "leased_fd",
      "type": "fd"
     }
    ],
    "opcode": 0
   },
   {
    "name": "finished",
    "args": [],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "a DRM lease\n\nA DRM lease object is used to transfer the DRM file descriptor to the\nclient and manage the lifetime of the lease.\n\nSome time after the wp_drm_lease_v1 object is created, the compositor\nwill reply with the lease request's result. If the lease request is\ngranted, the compositor will send a lease_fd event. If the lease request\nis denied, the compositor will send a finished event without a lease_fd\nevent.\n"
 },
 "ext_foreign_toplevel_list_v1": {
  "events": [
   {
    "name": "toplevel",
    "args": [
     {
      "name": "toplevel",
      "type": "new_id",
      "interface": "ext_foreign_toplevel_handle_v1"
     }
    ],
    "opcode": 0
   },
   {
    "name": "finished",
    "args": [],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "stop",
    "args": [],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "list toplevels\n\nA toplevel is defined as a surface with a role similar to xdg_toplevel.\nXWayland surfaces may be treated like toplevels in this protocol.\n\nAfter a client binds the ext_foreign_toplevel_list_v1, each mapped\ntoplevel window will be sent using the ext_foreign_toplevel_list_v1.toplevel\nevent.\n\nClients which only care about the current state can perform a roundtrip after\nbinding this global.\n\nFor each instance of ext_foreign_toplevel_list_v1, the compositor must\ncreate a new ext_foreign_toplevel_handle_v1 object for each mapped toplevel.\n\nIf a compositor implementation sends the ext_foreign_toplevel_list_v1.finished\nevent after the global is bound, the compositor must not send any\next_foreign_toplevel_list_v1.toplevel events.\n"
 },
 "ext_foreign_toplevel_handle_v1": {
  "events": [
   {
    "name": "closed",
    "args": [],
    "opcode": 0
   },
   {
    "name": "done",
    "args": [],
    "opcode": 1
   },
   {
    "name": "title",
    "args": [
     {
      "name": "title",
      "type": "string"
     }
    ],
    "opcode": 2
   },
   {
    "name": "app_id",
    "args": [
     {
      "name": "app_id",
      "type": "string"
     }
    ],
    "opcode": 3
   },
   {
    "name": "identifier",
    "args": [
     {
      "name": "identifier",
      "type": "string"
     }
    ],
    "opcode": 4
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "a mapped toplevel\n\nA ext_foreign_toplevel_handle_v1 object represents a mapped toplevel\nwindow. A single app may have multiple mapped toplevels.\n"
 },
 "ext_idle_notifier_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_idle_notification",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "ext_idle_notification_v1"
     },
     {
      "name": "timeout",
      "type": "uint"
     },
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "idle notification manager\n\nThis interface allows clients to monitor user idle status.\n\nAfter binding to this global, clients can create ext_idle_notification_v1\nobjects to get notified when the user is idle for a given amount of time.\n"
 },
 "ext_idle_notification_v1": {
  "events": [
   {
    "name": "idled",
    "args": [],
    "opcode": 0
   },
   {
    "name": "resumed",
    "args": [],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "idle notification\n\nThis interface is used by the compositor to send idle notification events\nto clients.\n\nInitially the notification object is not idle. The notification object\nbecomes idle when no user activity has happened for at least the timeout\nduration, starting from the creation of the notification object. User\nactivity may include input events or a presence sensor, but is\ncompositor-specific. If an idle inhibitor is active (e.g. another client\nhas created a zwp_idle_inhibitor_v1 on a visible surface), the compositor\nmust not make the notification object idle.\n\nWhen the notification object becomes idle, an idled event is sent. When\nuser activity starts again, the notification object stops being idle,\na resumed event is sent and the timeout is restarted.\n"
 },
 "ext_image_capture_source_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "opaque image capture source object\n\nThe image capture source object is an opaque descriptor for a capturable\nresource.  This resource may be any sort of entity from which an image\nmay be derived.\n\nNote, because ext_image_capture_source_v1 objects are created from multiple\nindependent factory interfaces, the ext_image_capture_source_v1 interface is\nfrozen at version 1.\n"
 },
 "ext_output_image_capture_source_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "create_source",
    "args": [
     {
      "name": "source",
      "type": "new_id",
      "interface": "ext_image_capture_source_v1"
     },
     {
      "name": "output",
      "type": "object",
      "interface": "wl_output"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "image capture source manager for outputs\n\nA manager for creating image capture source objects for wl_output objects.\n"
 },
 "ext_foreign_toplevel_image_capture_source_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "create_source",
    "args": [
     {
      "name": "source",
      "type": "new_id",
      "interface": "ext_image_capture_source_v1"
     },
     {
      "name": "toplevel_handle",
      "type": "object",
      "interface": "ext_foreign_toplevel_handle_v1"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "image capture source manager for foreign toplevels\n\nA manager for creating image capture source objects for\next_foreign_toplevel_handle_v1 objects.\n"
 },
 "ext_image_copy_capture_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "create_session",
    "args": [
     {
      "name": "session",
      "type": "new_id",
      "interface": "ext_image_copy_capture_session_v1"
     },
     {
      "name": "source",
      "type": "object",
      "interface": "ext_image_capture_source_v1"
     },
     {
      "name": "options",
      "type": "uint",
      "enum": "options"
     }
    ],
    "opcode": 0
   },
   {
    "name": "create_pointer_cursor_session",
    "args": [
     {
      "name": "session",
      "type": "new_id",
      "interface": "ext_image_copy_capture_cursor_session_v1"
     },
     {
      "name": "source",
      "type": "object",
      "interface": "ext_image_capture_source_v1"
     },
     {
      "name": "pointer",
      "type": "object",
      "interface": "wl_pointer"
     }
    ],
    "opcode": 1
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "manager to inform clients and begin capturing\n\nThis object is a manager which offers requests to start capturing from a\nsource.\n"
 },
 "ext_image_copy_capture_session_v1": {
  "events": [
   {
    "name": "buffer_size",
    "args": [
     {
      "name": "width",
      "type": "uint"
     },
     {
      "name": "height",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "shm_format",
    "args": [
     {
      "name": "format",
      "type": "uint",
      "enum": "wl_shm.format"
     }
    ],
    "opcode": 1
   },
   {
    "name": "dmabuf_device",
    "args": [
     {
      "name": "device",
      "type": "array"
     }
    ],
    "opcode": 2
   },
   {
    "name": "dmabuf_format",
    "args": [
     {
      "name": "format",
      "type": "uint"
     },
     {
      "name": "modifiers",
      "type": "array"
     }
    ],
    "opcode": 3
   },
   {
    "name": "done",
    "args": [],
    "opcode": 4
   },
   {
    "name": "stopped",
    "args": [],
    "opcode": 5
   }
  ],
  "methods": [
   {
    "name": "create_frame",
    "args": [
     {
      "name": "frame",
      "type": "new_id",
      "interface": "ext_image_copy_capture_frame_v1"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "image copy capture session\n\nThis object represents an active image copy capture session.\n\nAfter a capture session is created, buffer constraint events will be\nemitted from the compositor to tell the client which buffer types and\nformats are supported for reading from the session. The compositor may\nre-send buffer constraint events whenever they change.\n\nThe advertise buffer constraints, the compositor must send in no\nparticular order: zero or more shm_format and dmabuf_format events, zero\nor one dmabuf_device event, and exactly one buffer_size event. Then the\ncompositor must send a done event.\n\nWhen the client has received all the buffer constraints, it can create a\nbuffer accordingly, attach it to the capture session using the\nattach_buffer request, set the buffer damage using the damage_buffer\nrequest and then send the capture request.\n"
 },
 "ext_image_copy_capture_frame_v1": {
  "events": [
   {
    "name": "transform",
    "args": [
     {
      "name": "transform",
      "type": "uint",
      "enum": "wl_output.transform"
     }
    ],
    "opcode": 0
   },
   {
    "name": "damage",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 1
   },
   {
    "name": "presentation_time",
    "args": [
     {
      "name": "tv_sec_hi",
      "type": "uint"
     },
     {
      "name": "tv_sec_lo",
      "type": "uint"
     },
     {
      "name": "tv_nsec",
      "type": "uint"
     }
    ],
    "opcode": 2
   },
   {
    "name": "ready",
    "args": [],
    "opcode": 3
   },
   {
    "name": "failed",
    "args": [
     {
      "name": "reason",
      "type": "uint",
      "enum": "failure_reason"
     }
    ],
    "opcode": 4
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "attach_buffer",
    "args": [
     {
      "name": "buffer",
      "type": "object",
      "interface": "wl_buffer"
     }
    ],
    "opcode": 1
   },
   {
    "name": "damage_buffer",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 2
   },
   {
    "name": "capture",
    "args": [],
    "opcode": 3
   }
  ],
  "version": "1",
  "description": "image capture frame\n\nThis object represents an image capture frame.\n\nThe client should attach a buffer, damage the buffer, and then send a\ncapture request.\n\nIf the capture is successful, the compositor must send the frame metadata\n(transform, damage, presentation_time in any order) followed by the ready\nevent.\n\nIf the capture fails, the compositor must send the failed event.\n"
 },
 "ext_image_copy_capture_cursor_session_v1": {
  "events": [
   {
    "name": "enter",
    "args": [],
    "opcode": 0
   },
   {
    "name": "leave",
    "args": [],
    "opcode": 1
   },
   {
    "name": "position",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     }
    ],
    "opcode": 2
   },
   {
    "name": "hotspot",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     }
    ],
    "opcode": 3
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_capture_session",
    "args": [
     {
      "name": "session",
      "type": "new_id",
      "interface": "ext_image_copy_capture_session_v1"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "cursor capture session\n\nThis object represents a cursor capture session. It extends the base\ncapture session with cursor-specific metadata.\n"
 },
 "ext_session_lock_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "lock",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "ext_session_lock_v1"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "used to lock the session\n\nThis interface is used to request that the session be locked.\n"
 },
 "ext_session_lock_v1": {
  "events": [
   {
    "name": "locked",
    "args": [],
    "opcode": 0
   },
   {
    "name": "finished",
    "args": [],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_lock_surface",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "ext_session_lock_surface_v1"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "output",
      "type": "object",
      "interface": "wl_output"
     }
    ],
    "opcode": 1
   },
   {
    "name": "unlock_and_destroy",
    "type": "destructor",
    "args": [],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "manage lock state and create lock surfaces\n\nIn response to the creation of this object the compositor must send\neither the locked or finished event.\n\nThe locked event indicates that the session is locked. This means\nthat the compositor must stop rendering and providing input to normal\nclients. Instead the compositor must blank all outputs with an opaque\ncolor such that their normal content is fully hidden.\n\nThe only surfaces that should be rendered while the session is locked\nare the lock surfaces created through this interface and optionally,\nat the compositor's discretion, special privileged surfaces such as\ninput methods or portions of desktop shell UIs.\n\nThe locked event must not be sent until a new \"locked\" frame (either\nfrom a session lock surface or the compositor blanking the output) has\nbeen presented on all outputs and no security sensitive normal/unlocked\ncontent is possibly visible.\n\nThe finished event should be sent immediately on creation of this\nobject if the compositor decides that the locked event will not be sent.\n\nThe compositor may wait for the client to create and render session lock\nsurfaces before sending the locked event to avoid displaying intermediate\nblank frames. However, it must impose a reasonable time limit if\nwaiting and send the locked event as soon as the hard requirements\ndescribed above can be met if the time limit expires. Clients should\nimmediately create lock surfaces for all outputs on creation of this\nobject to make this possible.\n\nThis behavior of the locked event is required in order to prevent\npossible race conditions with clients that wish to suspend the system\nor similar after locking the session. Without these semantics, clients\ntriggering a suspend after receiving the locked event would race with\nthe first \"locked\" frame being presented and normal/unlocked frames\nmight be briefly visible as the system is resumed if the suspend\noperation wins the race.\n\nIf the client dies while the session is locked, the compositor must not\nunlock the session in response. It is acceptable for the session to be\npermanently locked if this happens. The compositor may choose to continue\nto display the lock surfaces the client had mapped before it died or\nalternatively fall back to a solid color, this is compositor policy.\n\nCompositors may also allow a secure way to recover the session, the\ndetails of this are compositor policy. Compositors may allow a new\nclient to create a ext_session_lock_v1 object and take responsibility\nfor unlocking the session, they may even start a new lock client\ninstance automatically.\n"
 },
 "ext_session_lock_surface_v1": {
  "events": [
   {
    "name": "configure",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "width",
      "type": "uint"
     },
     {
      "name": "height",
      "type": "uint"
     }
    ],
    "opcode": 0
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "ack_configure",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "a surface displayed while the session is locked\n\nThe client may use lock surfaces to display a screensaver, render a\ndialog to enter a password and unlock the session, or however else it\nsees fit.\n\nOn binding this interface the compositor will immediately send the\nfirst configure event. After making the ack_configure request in\nresponse to this event the client should attach and commit the first\nbuffer. Committing the surface before acking the first configure is a\nprotocol error. Committing the surface with a null buffer at any time\nis a protocol error.\n\nThe compositor is free to handle keyboard/pointer focus for lock\nsurfaces however it chooses. A reasonable way to do this would be to\ngive the first lock surface created keyboard focus and change keyboard\nfocus if the user clicks on other surfaces.\n"
 },
 "ext_transient_seat_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "create",
    "args": [
     {
      "name": "seat",
      "type": "new_id",
      "interface": "ext_transient_seat_v1"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "transient seat manager\n\nThe transient seat manager creates short-lived seats.\n"
 },
 "ext_transient_seat_v1": {
  "events": [
   {
    "name": "ready",
    "args": [
     {
      "name": "global_name",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "denied",
    "args": [],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "transient seat handle\n\nWhen the transient seat handle is destroyed, the seat itself will also be\ndestroyed.\n"
 },
 "wp_fractional_scale_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_fractional_scale",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_fractional_scale_v1"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "fractional surface scale information\n\nA global interface for requesting surfaces to use fractional scales.\n"
 },
 "wp_fractional_scale_v1": {
  "events": [
   {
    "name": "preferred_scale",
    "args": [
     {
      "name": "scale",
      "type": "uint"
     }
    ],
    "opcode": 0
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "fractional scale interface to a wl_surface\n\nAn additional interface to a wl_surface object which allows the compositor\nto inform the client of the preferred scale.\n"
 },
 "wp_linux_drm_syncobj_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_surface",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_linux_drm_syncobj_surface_v1"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   },
   {
    "name": "import_timeline",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_linux_drm_syncobj_timeline_v1"
     },
     {
      "name": "fd",
      "type": "fd"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "global for providing explicit synchronization\n\nThis global is a factory interface, allowing clients to request\nexplicit synchronization for buffers on a per-surface basis.\n\nSee wp_linux_drm_syncobj_surface_v1 for more information.\n"
 },
 "wp_linux_drm_syncobj_timeline_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "synchronization object timeline\n\nThis object represents an explicit synchronization object timeline\nimported by the client to the compositor.\n"
 },
 "wp_linux_drm_syncobj_surface_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_acquire_point",
    "args": [
     {
      "name": "timeline",
      "type": "object",
      "interface": "wp_linux_drm_syncobj_timeline_v1"
     },
     {
      "name": "point_hi",
      "type": "uint"
     },
     {
      "name": "point_lo",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "set_release_point",
    "args": [
     {
      "name": "timeline",
      "type": "object",
      "interface": "wp_linux_drm_syncobj_timeline_v1"
     },
     {
      "name": "point_hi",
      "type": "uint"
     },
     {
      "name": "point_lo",
      "type": "uint"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "per-surface explicit synchronization\n\nThis object is an add-on interface for wl_surface to enable explicit\nsynchronization.\n\nEach surface can be associated with only one object of this interface at\nany time.\n\nExplicit synchronization is guaranteed to be supported for buffers\ncreated with any version of the linux-dmabuf protocol. Compositors are\nfree to support explicit synchronization for additional buffer types.\nIf at surface commit time the attached buffer does not support explicit\nsynchronization, an unsupported_buffer error is raised.\n\nAs long as the wp_linux_drm_syncobj_surface_v1 object is alive, the\ncompositor may ignore implicit synchronization for buffers attached and\ncommitted to the wl_surface. The delivery of wl_buffer.release events\nfor buffers attached to the surface becomes undefined.\n\nClients must set both acquire and release points if and only if a\nnon-null buffer is attached in the same surface commit. See the\nno_buffer, no_acquire_point and no_release_point protocol errors.\n\nIf at surface commit time the acquire and release DRM syncobj timelines\nare identical, the acquire point value must be strictly less than the\nrelease point value, or else the conflicting_points protocol error is\nraised.\n"
 },
 "wp_security_context_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "create_listener",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_security_context_v1"
     },
     {
      "name": "listen_fd",
      "type": "fd"
     },
     {
      "name": "close_fd",
      "type": "fd"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "client security context manager\n\nThis interface allows a client to register a new Wayland connection to\nthe compositor and attach a security context to it.\n\nThis is intended to be used by sandboxes. Sandbox engines attach a\nsecurity context to all connections coming from inside the sandbox. The\ncompositor can then restrict the features that the sandboxed connections\ncan use.\n\nCompositors should forbid nesting multiple security contexts by not\nexposing wp_security_context_manager_v1 global to clients with a security\ncontext attached, or by sending the nested protocol error. Nested\nsecurity contexts are dangerous because they can potentially allow\nprivilege escalation of a sandboxed client.\n\nWarning! The protocol described in this file is currently in the testing\nphase. Backward compatible changes may be added together with the\ncorresponding interface version bump. Backward incompatible changes can\nonly be done by creating a new major version of the extension.\n"
 },
 "wp_security_context_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_sandbox_engine",
    "args": [
     {
      "name": "name",
      "type": "string"
     }
    ],
    "opcode": 1
   },
   {
    "name": "set_app_id",
    "args": [
     {
      "name": "app_id",
      "type": "string"
     }
    ],
    "opcode": 2
   },
   {
    "name": "set_instance_id",
    "args": [
     {
      "name": "instance_id",
      "type": "string"
     }
    ],
    "opcode": 3
   },
   {
    "name": "commit",
    "args": [],
    "opcode": 4
   }
  ],
  "version": "1",
  "description": "client security context\n\nThe security context allows a client to register a new client and attach\nsecurity context metadata to the connections.\n\nWhen both are set, the combination of the application ID and the sandbox\nengine must uniquely identify an application. The same application ID\nwill be used across instances (e.g. if the application is restarted, or\nif the application is started multiple times).\n\nWhen both are set, the combination of the instance ID and the sandbox\nengine must uniquely identify a running instance of an application.\n"
 },
 "wp_single_pixel_buffer_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "create_u32_rgba_buffer",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wl_buffer"
     },
     {
      "name": "r",
      "type": "uint"
     },
     {
      "name": "g",
      "type": "uint"
     },
     {
      "name": "b",
      "type": "uint"
     },
     {
      "name": "a",
      "type": "uint"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "global factory for single-pixel buffers\n\nThe wp_single_pixel_buffer_manager_v1 interface is a factory for\nsingle-pixel buffers.\n"
 },
 "wp_tearing_control_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_tearing_control",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_tearing_control_v1"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "protocol for tearing control\n\nFor some use cases like games or drawing tablets it can make sense to\nreduce latency by accepting tearing with the use of asynchronous page\nflips. This global is a factory interface, allowing clients to inform\nwhich type of presentation the content of their surfaces is suitable for.\n\nGraphics APIs like EGL or Vulkan, that manage the buffer queue and commits\nof a wl_surface themselves, are likely to be using this extension\ninternally. If a client is using such an API for a wl_surface, it should\nnot directly use this extension on that surface, to avoid raising a\ntearing_control_exists protocol error.\n\nWarning! The protocol described in this file is currently in the testing\nphase. Backward compatible changes may be added together with the\ncorresponding interface version bump. Backward incompatible changes can\nonly be done by creating a new major version of the extension.\n"
 },
 "wp_tearing_control_v1": {
  "events": [],
  "methods": [
   {
    "name": "set_presentation_hint",
    "args": [
     {
      "name": "hint",
      "type": "uint",
      "enum": "presentation_hint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "per-surface tearing control interface\n\nAn additional interface to a wl_surface object, which allows the client\nto hint to the compositor if the content on the surface is suitable for\npresentation with tearing.\nThe default presentation hint is vsync. See presentation_hint for more\ndetails.\n\nIf the associated wl_surface is destroyed, this object becomes inert and\nshould be destroyed.\n"
 },
 "xdg_activation_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_activation_token",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xdg_activation_token_v1"
     }
    ],
    "opcode": 1
   },
   {
    "name": "activate",
    "args": [
     {
      "name": "token",
      "type": "string"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "interface for activating surfaces\n\nA global interface used for informing the compositor about applications\nbeing activated or started, or for applications to request to be\nactivated.\n"
 },
 "xdg_activation_token_v1": {
  "events": [
   {
    "name": "done",
    "args": [
     {
      "name": "token",
      "type": "string"
     }
    ],
    "opcode": 0
   }
  ],
  "methods": [
   {
    "name": "set_serial",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     }
    ],
    "opcode": 0
   },
   {
    "name": "set_app_id",
    "args": [
     {
      "name": "app_id",
      "type": "string"
     }
    ],
    "opcode": 1
   },
   {
    "name": "set_surface",
    "args": [
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 2
   },
   {
    "name": "commit",
    "args": [],
    "opcode": 3
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 4
   }
  ],
  "version": "1",
  "description": "an exported activation handle\n\nAn object for setting up a token and receiving a token handle that can\nbe passed as an activation token to another client.\n\nThe object is created using the xdg_activation_v1.get_activation_token\nrequest. This object should then be populated with the app_id, surface\nand serial information and committed. The compositor shall then issue a\ndone event with the token. In case the request's parameters are invalid,\nthe compositor will provide an invalid token.\n"
 },
 "xdg_wm_dialog_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_xdg_dialog",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xdg_dialog_v1"
     },
     {
      "name": "toplevel",
      "type": "object",
      "interface": "xdg_toplevel"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "create dialogs related to other toplevels\n\nThe xdg_wm_dialog_v1 interface is exposed as a global object allowing\nto register surfaces with a xdg_toplevel role as \"dialogs\" relative to\nanother toplevel.\n\nThe compositor may let this relation influence how the surface is\nplaced, displayed or interacted with.\n\nWarning! The protocol described in this file is currently in the testing\nphase. Backward compatible changes may be added together with the\ncorresponding interface version bump. Backward incompatible changes can\nonly be done by creating a new major version of the extension.\n"
 },
 "xdg_dialog_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_modal",
    "args": [],
    "opcode": 1
   },
   {
    "name": "unset_modal",
    "args": [],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "dialog object\n\nA xdg_dialog_v1 object is an ancillary object tied to a xdg_toplevel. Its\npurpose is hinting the compositor that the toplevel is a \"dialog\" (e.g. a\ntemporary window) relative to another toplevel (see\nxdg_toplevel.set_parent). If the xdg_toplevel is destroyed, the xdg_dialog_v1\nbecomes inert.\n\nThrough this object, the client may provide additional hints about\nthe purpose of the secondary toplevel. This interface has no effect\non toplevels that are not attached to a parent toplevel.\n"
 },
 "xdg_toplevel_drag_manager_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_xdg_toplevel_drag",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xdg_toplevel_drag_v1"
     },
     {
      "name": "data_source",
      "type": "object",
      "interface": "wl_data_source"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "Move a window during a drag\n\nThis protocol enhances normal drag and drop with the ability to move a\nwindow at the same time. This allows having detachable parts of a window\nthat when dragged out of it become a new window and can be dragged over\nan existing window to be reattached.\n\nA typical workflow would be when the user starts dragging on top of a\ndetachable part of a window, the client would create a wl_data_source and\na xdg_toplevel_drag_v1 object and start the drag as normal via\nwl_data_device.start_drag. Once the client determines that the detachable\nwindow contents should be detached from the originating window, it creates\na new xdg_toplevel with these contents and issues a\nxdg_toplevel_drag_v1.attach request before mapping it. From now on the new\nwindow is moved by the compositor during the drag as if the client called\nxdg_toplevel.move.\n\nDragging an existing window is similar. The client creates a\nxdg_toplevel_drag_v1 object and attaches the existing toplevel before\nstarting the drag.\n\nClients use the existing drag and drop mechanism to detect when a window\ncan be docked or undocked. If the client wants to snap a window into a\nparent window it should delete or unmap the dragged top-level. If the\ncontents should be detached again it attaches a new toplevel as described\nabove. If a drag operation is cancelled without being dropped, clients\nshould revert to the previous state, deleting any newly created windows\nas appropriate. When a drag operation ends as indicated by\nwl_data_source.dnd_drop_performed the dragged toplevel window's final\nposition is determined as if a xdg_toplevel_move operation ended.\n\nWarning! The protocol described in this file is currently in the testing\nphase. Backward compatible changes may be added together with the\ncorresponding interface version bump. Backward incompatible changes can\nonly be done by creating a new major version of the extension.\n"
 },
 "xdg_toplevel_drag_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "attach",
    "args": [
     {
      "name": "toplevel",
      "type": "object",
      "interface": "xdg_toplevel"
     },
     {
      "name": "x_offset",
      "type": "int"
     },
     {
      "name": "y_offset",
      "type": "int"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "Object representing a toplevel move during a drag\n\n"
 },
 "xdg_toplevel_icon_manager_v1": {
  "events": [
   {
    "name": "icon_size",
    "args": [
     {
      "name": "size",
      "type": "int"
     }
    ],
    "opcode": 0
   },
   {
    "name": "done",
    "args": [],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "create_icon",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xdg_toplevel_icon_v1"
     }
    ],
    "opcode": 1
   },
   {
    "name": "set_icon",
    "args": [
     {
      "name": "toplevel",
      "type": "object",
      "interface": "xdg_toplevel"
     },
     {
      "name": "icon",
      "type": "object",
      "interface": "xdg_toplevel_icon_v1",
      "allow-null": "true"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "interface to manage toplevel icons\n\nThis interface allows clients to create toplevel window icons and set\nthem on toplevel windows to be displayed to the user.\n"
 },
 "xdg_toplevel_icon_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_name",
    "args": [
     {
      "name": "icon_name",
      "type": "string"
     }
    ],
    "opcode": 1
   },
   {
    "name": "add_buffer",
    "args": [
     {
      "name": "buffer",
      "type": "object",
      "interface": "wl_buffer"
     },
     {
      "name": "scale",
      "type": "int"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "a toplevel window icon\n\nThis interface defines a toplevel icon.\nAn icon can have a name, and multiple buffers.\nIn order to be applied, the icon must have either a name, or at least\none buffer assigned. Applying an empty icon (with no buffer or name) to\na toplevel should reset its icon to the default icon.\n\nIt is up to compositor policy whether to prefer using a buffer or loading\nan icon via its name. See 'set_name' and 'add_buffer' for details.\n"
 },
 "xwayland_shell_v1": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_xwayland_surface",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xwayland_surface_v1"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "context object for Xwayland shell\n\nxwayland_shell_v1 is a singleton global object that\nprovides the ability to create a xwayland_surface_v1 object\nfor a given wl_surface.\n\nThis interface is intended to be bound by the Xwayland server.\n\nA compositor must not allow clients other than Xwayland to\nbind to this interface. A compositor should hide this global\nfrom other clients' wl_registry.\nA client the compositor does not consider to be an Xwayland\nserver attempting to bind this interface will result in\nan implementation-defined error.\n\nAn Xwayland server that has bound this interface must not\nset the `WL_SURFACE_ID` atom on a window.\n"
 },
 "xwayland_surface_v1": {
  "events": [],
  "methods": [
   {
    "name": "set_serial",
    "args": [
     {
      "name": "serial_lo",
      "type": "uint"
     },
     {
      "name": "serial_hi",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "interface for associating Xwayland windows to wl_surfaces\n\nAn Xwayland surface is a surface managed by an Xwayland server.\nIt is used for associating surfaces to Xwayland windows.\n\nThe Xwayland server associated with actions in this interface is\ndetermined by the Wayland client making the request.\n\nThe client must call wl_surface.commit on the corresponding wl_surface\nfor the xwayland_surface_v1 state to take effect.\n"
 },
 "zwp_linux_dmabuf_v1": {
  "events": [
   {
    "name": "format",
    "args": [
     {
      "name": "format",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "modifier",
    "since": "3",
    "args": [
     {
      "name": "format",
      "type": "uint"
     },
     {
      "name": "modifier_hi",
      "type": "uint"
     },
     {
      "name": "modifier_lo",
      "type": "uint"
     }
    ],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "create_params",
    "args": [
     {
      "name": "params_id",
      "type": "new_id",
      "interface": "zwp_linux_buffer_params_v1"
     }
    ],
    "opcode": 1
   },
   {
    "name": "get_default_feedback",
    "since": "4",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "zwp_linux_dmabuf_feedback_v1"
     }
    ],
    "opcode": 2
   },
   {
    "name": "get_surface_feedback",
    "since": "4",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "zwp_linux_dmabuf_feedback_v1"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 3
   }
  ],
  "version": "5",
  "description": "factory for creating dmabuf-based wl_buffers\n\nFollowing the interfaces from:\nhttps://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt\nhttps://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt\nand the Linux DRM sub-system's AddFb2 ioctl.\n\nThis interface offers ways to create generic dmabuf-based wl_buffers.\n\nClients can use the get_surface_feedback request to get dmabuf feedback\nfor a particular surface. If the client wants to retrieve feedback not\ntied to a surface, they can use the get_default_feedback request.\n\nThe following are required from clients:\n\n- Clients must ensure that either all data in the dma-buf is\ncoherent for all subsequent read access or that coherency is\ncorrectly handled by the underlying kernel-side dma-buf\nimplementation.\n\n- Don't make any more attachments after sending the buffer to the\ncompositor. Making more attachments later increases the risk of\nthe compositor not being able to use (re-import) an existing\ndmabuf-based wl_buffer.\n\nThe underlying graphics stack must ensure the following:\n\n- The dmabuf file descriptors relayed to the server will stay valid\nfor the whole lifetime of the wl_buffer. This means the server may\nat any time use those fds to import the dmabuf into any kernel\nsub-system that might accept it.\n\nHowever, when the underlying graphics stack fails to deliver the\npromise, because of e.g. a device hot-unplug which raises internal\nerrors, after the wl_buffer has been successfully created the\ncompositor must not raise protocol errors to the client when dmabuf\nimport later fails.\n\nTo create a wl_buffer from one or more dmabufs, a client creates a\nzwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params\nrequest. All planes required by the intended format are added with\nthe 'add' request. Finally, a 'create' or 'create_immed' request is\nissued, which has the following outcome depending on the import success.\n\nThe 'create' request,\n- on success, triggers a 'created' event which provides the final\nwl_buffer to the client.\n- on failure, triggers a 'failed' event to convey that the server\ncannot use the dmabufs received from the client.\n\nFor the 'create_immed' request,\n- on success, the server immediately imports the added dmabufs to\ncreate a wl_buffer. No event is sent from the server in this case.\n- on failure, the server can choose to either:\n- terminate the client by raising a fatal error.\n- mark the wl_buffer as failed, and send a 'failed' event to the\nclient. If the client uses a failed wl_buffer as an argument to any\nrequest, the behaviour is compositor implementation-defined.\n\nFor all DRM formats and unless specified in another protocol extension,\npre-multiplied alpha is used for pixel values.\n\nUnless specified otherwise in another protocol extension, implicit\nsynchronization is used. In other words, compositors and clients must\nwait and signal fences implicitly passed via the DMA-BUF's reservation\nmechanism.\n"
 },
 "zwp_linux_buffer_params_v1": {
  "events": [
   {
    "name": "created",
    "args": [
     {
      "name": "buffer",
      "type": "new_id",
      "interface": "wl_buffer"
     }
    ],
    "opcode": 0
   },
   {
    "name": "failed",
    "args": [],
    "opcode": 1
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "add",
    "args": [
     {
      "name": "fd",
      "type": "fd"
     },
     {
      "name": "plane_idx",
      "type": "uint"
     },
     {
      "name": "offset",
      "type": "uint"
     },
     {
      "name": "stride",
      "type": "uint"
     },
     {
      "name": "modifier_hi",
      "type": "uint"
     },
     {
      "name": "modifier_lo",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "create",
    "args": [
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     },
     {
      "name": "format",
      "type": "uint"
     },
     {
      "name": "flags",
      "type": "uint",
      "enum": "flags"
     }
    ],
    "opcode": 2
   },
   {
    "name": "create_immed",
    "since": "2",
    "args": [
     {
      "name": "buffer_id",
      "type": "new_id",
      "interface": "wl_buffer"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     },
     {
      "name": "format",
      "type": "uint"
     },
     {
      "name": "flags",
      "type": "uint",
      "enum": "flags"
     }
    ],
    "opcode": 3
   }
  ],
  "version": "5",
  "description": "parameters for creating a dmabuf-based wl_buffer\n\nThis temporary object is a collection of dmabufs and other\nparameters that together form a single logical buffer. The temporary\nobject may eventually create one wl_buffer unless cancelled by\ndestroying it before requesting 'create'.\n\nSingle-planar formats only require one dmabuf, however\nmulti-planar formats may require more than one dmabuf. For all\nformats, an 'add' request must be called once per plane (even if the\nunderlying dmabuf fd is identical).\n\nYou must use consecutive plane indices ('plane_idx' argument for 'add')\nfrom zero to the number of planes used by the drm_fourcc format code.\nAll planes required by the format must be given exactly once, but can\nbe given in any order. Each plane index can be set only once.\n"
 },
 "zwp_linux_dmabuf_feedback_v1": {
  "events": [
   {
    "name": "done",
    "args": [],
    "opcode": 0
   },
   {
    "name": "format_table",
    "args": [
     {
      "name": "fd",
      "type": "fd"
     },
     {
      "name": "size",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "main_device",
    "args": [
     {
      "name": "device",
      "type": "array"
     }
    ],
    "opcode": 2
   },
   {
    "name": "tranche_done",
    "args": [],
    "opcode": 3
   },
   {
    "name": "tranche_target_device",
    "args": [
     {
      "name": "device",
      "type": "array"
     }
    ],
    "opcode": 4
   },
   {
    "name": "tranche_formats",
    "args": [
     {
      "name": "indices",
      "type": "array"
     }
    ],
    "opcode": 5
   },
   {
    "name": "tranche_flags",
    "args": [
     {
      "name": "flags",
      "type": "uint",
      "enum": "tranche_flags"
     }
    ],
    "opcode": 6
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "5",
  "description": "dmabuf feedback\n\nThis object advertises dmabuf parameters feedback. This includes the\npreferred devices and the supported formats/modifiers.\n\nThe parameters are sent once when this object is created and whenever they\nchange. The done event is always sent once after all parameters have been\nsent. When a single parameter changes, all parameters are re-sent by the\ncompositor.\n\nCompositors can re-send the parameters when the current client buffer\nallocations are sub-optimal. Compositors should not re-send the\nparameters if re-allocating the buffers would not result in a more optimal\nconfiguration. In particular, compositors should avoid sending the exact\nsame parameters multiple times in a row.\n\nThe tranche_target_device and tranche_formats events are grouped by\ntranches of preference. For each tranche, a tranche_target_device, one\ntranche_flags and one or more tranche_formats events are sent, followed\nby a tranche_done event finishing the list. The tranches are sent in\ndescending order of preference. All formats and modifiers in the same\ntranche have the same preference.\n\nTo send parameters, the compositor sends one main_device event, tranches\n(each consisting of one tranche_target_device event, one tranche_flags\nevent, tranche_formats events and then a tranche_done event), then one\ndone event.\n"
 },
 "wp_presentation": {
  "events": [
   {
    "name": "clock_id",
    "args": [
     {
      "name": "clk_id",
      "type": "uint"
     }
    ],
    "opcode": 0
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "feedback",
    "args": [
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     },
     {
      "name": "callback",
      "type": "new_id",
      "interface": "wp_presentation_feedback"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "timed presentation related wl_surface requests\n\n\n"
 },
 "wp_presentation_feedback": {
  "events": [
   {
    "name": "sync_output",
    "args": [
     {
      "name": "output",
      "type": "object",
      "interface": "wl_output"
     }
    ],
    "opcode": 0
   },
   {
    "name": "presented",
    "type": "destructor",
    "args": [
     {
      "name": "tv_sec_hi",
      "type": "uint"
     },
     {
      "name": "tv_sec_lo",
      "type": "uint"
     },
     {
      "name": "tv_nsec",
      "type": "uint"
     },
     {
      "name": "refresh",
      "type": "uint"
     },
     {
      "name": "seq_hi",
      "type": "uint"
     },
     {
      "name": "seq_lo",
      "type": "uint"
     },
     {
      "name": "flags",
      "type": "uint",
      "enum": "kind"
     }
    ],
    "opcode": 1
   },
   {
    "name": "discarded",
    "type": "destructor",
    "args": [],
    "opcode": 2
   }
  ],
  "methods": [],
  "version": "1",
  "description": "presentation time feedback event\n\nA presentation_feedback object returns an indication that a\nwl_surface content update has become visible to the user.\nOne object corresponds to one content update submission\n(wl_surface.commit). There are two possible outcomes: the\ncontent update is presented to the user, and a presentation\ntimestamp delivered; or, the user did not see the content\nupdate because it was superseded or its surface destroyed,\nand the content update is discarded.\n\nOnce a presentation_feedback object has delivered a 'presented'\nor 'discarded' event it is automatically destroyed.\n"
 },
 "zwp_tablet_manager_v2": {
  "events": [],
  "methods": [
   {
    "name": "get_tablet_seat",
    "args": [
     {
      "name": "tablet_seat",
      "type": "new_id",
      "interface": "zwp_tablet_seat_v2"
     },
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "controller object for graphic tablet devices\n\nAn object that provides access to the graphics tablets available on this\nsystem. All tablets are associated with a seat, to get access to the\nactual tablets, use wp_tablet_manager.get_tablet_seat.\n"
 },
 "zwp_tablet_seat_v2": {
  "events": [
   {
    "name": "tablet_added",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "zwp_tablet_v2"
     }
    ],
    "opcode": 0
   },
   {
    "name": "tool_added",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "zwp_tablet_tool_v2"
     }
    ],
    "opcode": 1
   },
   {
    "name": "pad_added",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "zwp_tablet_pad_v2"
     }
    ],
    "opcode": 2
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "controller object for graphic tablet devices of a seat\n\nAn object that provides access to the graphics tablets available on this\nseat. After binding to this interface, the compositor sends a set of\nwp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.\n"
 },
 "zwp_tablet_tool_v2": {
  "events": [
   {
    "name": "type",
    "args": [
     {
      "name": "tool_type",
      "type": "uint",
      "enum": "type"
     }
    ],
    "opcode": 0
   },
   {
    "name": "hardware_serial",
    "args": [
     {
      "name": "hardware_serial_hi",
      "type": "uint"
     },
     {
      "name": "hardware_serial_lo",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "hardware_id_wacom",
    "args": [
     {
      "name": "hardware_id_hi",
      "type": "uint"
     },
     {
      "name": "hardware_id_lo",
      "type": "uint"
     }
    ],
    "opcode": 2
   },
   {
    "name": "capability",
    "args": [
     {
      "name": "capability",
      "type": "uint",
      "enum": "capability"
     }
    ],
    "opcode": 3
   },
   {
    "name": "done",
    "args": [],
    "opcode": 4
   },
   {
    "name": "removed",
    "args": [],
    "opcode": 5
   },
   {
    "name": "proximity_in",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "tablet",
      "type": "object",
      "interface": "zwp_tablet_v2"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 6
   },
   {
    "name": "proximity_out",
    "args": [],
    "opcode": 7
   },
   {
    "name": "down",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 8
   },
   {
    "name": "up",
    "args": [],
    "opcode": 9
   },
   {
    "name": "motion",
    "args": [
     {
      "name": "x",
      "type": "fixed"
     },
     {
      "name": "y",
      "type": "fixed"
     }
    ],
    "opcode": 10
   },
   {
    "name": "pressure",
    "args": [
     {
      "name": "pressure",
      "type": "uint"
     }
    ],
    "opcode": 11
   },
   {
    "name": "distance",
    "args": [
     {
      "name": "distance",
      "type": "uint"
     }
    ],
    "opcode": 12
   },
   {
    "name": "tilt",
    "args": [
     {
      "name": "tilt_x",
      "type": "fixed"
     },
     {
      "name": "tilt_y",
      "type": "fixed"
     }
    ],
    "opcode": 13
   },
   {
    "name": "rotation",
    "args": [
     {
      "name": "degrees",
      "type": "fixed"
     }
    ],
    "opcode": 14
   },
   {
    "name": "slider",
    "args": [
     {
      "name": "position",
      "type": "int"
     }
    ],
    "opcode": 15
   },
   {
    "name": "wheel",
    "args": [
     {
      "name": "degrees",
      "type": "fixed"
     },
     {
      "name": "clicks",
      "type": "int"
     }
    ],
    "opcode": 16
   },
   {
    "name": "button",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "button",
      "type": "uint"
     },
     {
      "name": "state",
      "type": "uint",
      "enum": "button_state"
     }
    ],
    "opcode": 17
   },
   {
    "name": "frame",
    "args": [
     {
      "name": "time",
      "type": "uint"
     }
    ],
    "opcode": 18
   }
  ],
  "methods": [
   {
    "name": "set_cursor",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface",
      "allow-null": "true"
     },
     {
      "name": "hotspot_x",
      "type": "int"
     },
     {
      "name": "hotspot_y",
      "type": "int"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "a physical tablet tool\n\nAn object that represents a physical tool that has been, or is\ncurrently in use with a tablet in this seat. Each wp_tablet_tool\nobject stays valid until the client destroys it; the compositor\nreuses the wp_tablet_tool object to indicate that the object's\nrespective physical tool has come into proximity of a tablet again.\n\nA wp_tablet_tool object's relation to a physical tool depends on the\ntablet's ability to report serial numbers. If the tablet supports\nthis capability, then the object represents a specific physical tool\nand can be identified even when used on multiple tablets.\n\nA tablet tool has a number of static characteristics, e.g. tool type,\nhardware_serial and capabilities. These capabilities are sent in an\nevent sequence after the wp_tablet_seat.tool_added event before any\nactual events from this tool. This initial event sequence is\nterminated by a wp_tablet_tool.done event.\n\nTablet tool events are grouped by wp_tablet_tool.frame events.\nAny events received before a wp_tablet_tool.frame event should be\nconsidered part of the same hardware state change.\n"
 },
 "zwp_tablet_v2": {
  "events": [
   {
    "name": "name",
    "args": [
     {
      "name": "name",
      "type": "string"
     }
    ],
    "opcode": 0
   },
   {
    "name": "id",
    "args": [
     {
      "name": "vid",
      "type": "uint"
     },
     {
      "name": "pid",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "path",
    "args": [
     {
      "name": "path",
      "type": "string"
     }
    ],
    "opcode": 2
   },
   {
    "name": "done",
    "args": [],
    "opcode": 3
   },
   {
    "name": "removed",
    "args": [],
    "opcode": 4
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "graphics tablet device\n\nThe wp_tablet interface represents one graphics tablet device. The\ntablet interface itself does not generate events; all events are\ngenerated by wp_tablet_tool objects when in proximity above a tablet.\n\nA tablet has a number of static characteristics, e.g. device name and\npid/vid. These capabilities are sent in an event sequence after the\nwp_tablet_seat.tablet_added event. This initial event sequence is\nterminated by a wp_tablet.done event.\n"
 },
 "zwp_tablet_pad_ring_v2": {
  "events": [
   {
    "name": "source",
    "args": [
     {
      "name": "source",
      "type": "uint",
      "enum": "source"
     }
    ],
    "opcode": 0
   },
   {
    "name": "angle",
    "args": [
     {
      "name": "degrees",
      "type": "fixed"
     }
    ],
    "opcode": 1
   },
   {
    "name": "stop",
    "args": [],
    "opcode": 2
   },
   {
    "name": "frame",
    "args": [
     {
      "name": "time",
      "type": "uint"
     }
    ],
    "opcode": 3
   }
  ],
  "methods": [
   {
    "name": "set_feedback",
    "args": [
     {
      "name": "description",
      "type": "string"
     },
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "pad ring\n\nA circular interaction area, such as the touch ring on the Wacom Intuos\nPro series tablets.\n\nEvents on a ring are logically grouped by the wl_tablet_pad_ring.frame\nevent.\n"
 },
 "zwp_tablet_pad_strip_v2": {
  "events": [
   {
    "name": "source",
    "args": [
     {
      "name": "source",
      "type": "uint",
      "enum": "source"
     }
    ],
    "opcode": 0
   },
   {
    "name": "position",
    "args": [
     {
      "name": "position",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "stop",
    "args": [],
    "opcode": 2
   },
   {
    "name": "frame",
    "args": [
     {
      "name": "time",
      "type": "uint"
     }
    ],
    "opcode": 3
   }
  ],
  "methods": [
   {
    "name": "set_feedback",
    "args": [
     {
      "name": "description",
      "type": "string"
     },
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "pad strip\n\nA linear interaction area, such as the strips found in Wacom Cintiq\nmodels.\n\nEvents on a strip are logically grouped by the wl_tablet_pad_strip.frame\nevent.\n"
 },
 "zwp_tablet_pad_group_v2": {
  "events": [
   {
    "name": "buttons",
    "args": [
     {
      "name": "buttons",
      "type": "array"
     }
    ],
    "opcode": 0
   },
   {
    "name": "ring",
    "args": [
     {
      "name": "ring",
      "type": "new_id",
      "interface": "zwp_tablet_pad_ring_v2"
     }
    ],
    "opcode": 1
   },
   {
    "name": "strip",
    "args": [
     {
      "name": "strip",
      "type": "new_id",
      "interface": "zwp_tablet_pad_strip_v2"
     }
    ],
    "opcode": 2
   },
   {
    "name": "modes",
    "args": [
     {
      "name": "modes",
      "type": "uint"
     }
    ],
    "opcode": 3
   },
   {
    "name": "done",
    "args": [],
    "opcode": 4
   },
   {
    "name": "mode_switch",
    "args": [
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "mode",
      "type": "uint"
     }
    ],
    "opcode": 5
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   }
  ],
  "version": "1",
  "description": "a set of buttons, rings and strips\n\nA pad group describes a distinct (sub)set of buttons, rings and strips\npresent in the tablet. The criteria of this grouping is usually positional,\neg. if a tablet has buttons on the left and right side, 2 groups will be\npresented. The physical arrangement of groups is undisclosed and may\nchange on the fly.\n\nPad groups will announce their features during pad initialization. Between\nthe corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the\npad group will announce the buttons, rings and strips contained in it,\nplus the number of supported modes.\n\nModes are a mechanism to allow multiple groups of actions for every element\nin the pad group. The number of groups and available modes in each is\npersistent across device plugs. The current mode is user-switchable, it\nwill be announced through the wp_tablet_pad_group.mode_switch event both\nwhenever it is switched, and after wp_tablet_pad.enter.\n\nThe current mode logically applies to all elements in the pad group,\nalthough it is at clients' discretion whether to actually perform different\nactions, and/or issue the respective .set_feedback requests to notify the\ncompositor. See the wp_tablet_pad_group.mode_switch event for more details.\n"
 },
 "zwp_tablet_pad_v2": {
  "events": [
   {
    "name": "group",
    "args": [
     {
      "name": "pad_group",
      "type": "new_id",
      "interface": "zwp_tablet_pad_group_v2"
     }
    ],
    "opcode": 0
   },
   {
    "name": "path",
    "args": [
     {
      "name": "path",
      "type": "string"
     }
    ],
    "opcode": 1
   },
   {
    "name": "buttons",
    "args": [
     {
      "name": "buttons",
      "type": "uint"
     }
    ],
    "opcode": 2
   },
   {
    "name": "done",
    "args": [],
    "opcode": 3
   },
   {
    "name": "button",
    "args": [
     {
      "name": "time",
      "type": "uint"
     },
     {
      "name": "button",
      "type": "uint"
     },
     {
      "name": "state",
      "type": "uint",
      "enum": "button_state"
     }
    ],
    "opcode": 4
   },
   {
    "name": "enter",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "tablet",
      "type": "object",
      "interface": "zwp_tablet_v2"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 5
   },
   {
    "name": "leave",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 6
   },
   {
    "name": "removed",
    "args": [],
    "opcode": 7
   }
  ],
  "methods": [
   {
    "name": "set_feedback",
    "args": [
     {
      "name": "button",
      "type": "uint"
     },
     {
      "name": "description",
      "type": "string"
     },
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 0
   },
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "a set of buttons, rings and strips\n\nA pad device is a set of buttons, rings and strips\nusually physically present on the tablet device itself. Some\nexceptions exist where the pad device is physically detached, e.g. the\nWacom ExpressKey Remote.\n\nPad devices have no axes that control the cursor and are generally\nauxiliary devices to the tool devices used on the tablet surface.\n\nA pad device has a number of static characteristics, e.g. the number\nof rings. These capabilities are sent in an event sequence after the\nwp_tablet_seat.pad_added event before any actual events from this pad.\nThis initial event sequence is terminated by a wp_tablet_pad.done\nevent.\n\nAll pad features (buttons, rings and strips) are logically divided into\ngroups and all pads have at least one group. The available groups are\nnotified through the wp_tablet_pad.group event; the compositor will\nemit one event per group before emitting wp_tablet_pad.done.\n\nGroups may have multiple modes. Modes allow clients to map multiple\nactions to a single pad feature. Only one mode can be active per group,\nalthough different groups may have different active modes.\n"
 },
 "wp_viewporter": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_viewport",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "wp_viewport"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 1
   }
  ],
  "version": "1",
  "description": "surface cropping and scaling\n\nThe global interface exposing surface cropping and scaling\ncapabilities is used to instantiate an interface extension for a\nwl_surface object. This extended interface will then allow\ncropping and scaling the surface contents, effectively\ndisconnecting the direct relationship between the buffer and the\nsurface size.\n"
 },
 "wp_viewport": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_source",
    "args": [
     {
      "name": "x",
      "type": "fixed"
     },
     {
      "name": "y",
      "type": "fixed"
     },
     {
      "name": "width",
      "type": "fixed"
     },
     {
      "name": "height",
      "type": "fixed"
     }
    ],
    "opcode": 1
   },
   {
    "name": "set_destination",
    "args": [
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "1",
  "description": "crop and scale interface to a wl_surface\n\nAn additional interface to a wl_surface object, which allows the\nclient to specify the cropping and scaling of the surface\ncontents.\n\nThis interface works with two concepts: the source rectangle (src_x,\nsrc_y, src_width, src_height), and the destination size (dst_width,\ndst_height). The contents of the source rectangle are scaled to the\ndestination size, and content outside the source rectangle is ignored.\nThis state is double-buffered, see wl_surface.commit.\n\nThe two parts of crop and scale state are independent: the source\nrectangle, and the destination size. Initially both are unset, that\nis, no scaling is applied. The whole of the current wl_buffer is\nused as the source, and the surface size is as defined in\nwl_surface.attach.\n\nIf the destination size is set, it causes the surface size to become\ndst_width, dst_height. The source (rectangle) is scaled to exactly\nthis size. This overrides whatever the attached wl_buffer size is,\nunless the wl_buffer is NULL. If the wl_buffer is NULL, the surface\nhas no content and therefore no size. Otherwise, the size is always\nat least 1x1 in surface local coordinates.\n\nIf the source rectangle is set, it defines what area of the wl_buffer is\ntaken as the source. If the source rectangle is set and the destination\nsize is not set, then src_width and src_height must be integers, and the\nsurface size becomes the source rectangle size. This results in cropping\nwithout scaling. If src_width or src_height are not integers and\ndestination size is not set, the bad_size protocol error is raised when\nthe surface state is applied.\n\nThe coordinate transformations from buffer pixel coordinates up to\nthe surface-local coordinates happen in the following order:\n1. buffer_transform (wl_surface.set_buffer_transform)\n2. buffer_scale (wl_surface.set_buffer_scale)\n3. crop and scale (wp_viewport.set*)\nThis means, that the source rectangle coordinates of crop and scale\nare given in the coordinates after the buffer transform and scale,\ni.e. in the coordinates that would be the surface-local coordinates\nif the crop and scale was not applied.\n\nIf src_x or src_y are negative, the bad_value protocol error is raised.\nOtherwise, if the source rectangle is partially or completely outside of\nthe non-NULL wl_buffer, then the out_of_buffer protocol error is raised\nwhen the surface state is applied. A NULL wl_buffer does not raise the\nout_of_buffer error.\n\nIf the wl_surface associated with the wp_viewport is destroyed,\nall wp_viewport requests except 'destroy' raise the protocol error\nno_surface.\n\nIf the wp_viewport object is destroyed, the crop and scale\nstate is removed from the wl_surface. The change will be applied\non the next wl_surface.commit.\n"
 },
 "xdg_wm_base": {
  "events": [
   {
    "name": "ping",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 0
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "create_positioner",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xdg_positioner"
     }
    ],
    "opcode": 1
   },
   {
    "name": "get_xdg_surface",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xdg_surface"
     },
     {
      "name": "surface",
      "type": "object",
      "interface": "wl_surface"
     }
    ],
    "opcode": 2
   },
   {
    "name": "pong",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 3
   }
  ],
  "version": "6",
  "description": "create desktop-style surfaces\n\nThe xdg_wm_base interface is exposed as a global object enabling clients\nto turn their wl_surfaces into windows in a desktop environment. It\ndefines the basic functionality needed for clients and the compositor to\ncreate windows that can be dragged, resized, maximized, etc, as well as\ncreating transient windows such as popup menus.\n"
 },
 "xdg_positioner": {
  "events": [],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_size",
    "args": [
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 1
   },
   {
    "name": "set_anchor_rect",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 2
   },
   {
    "name": "set_anchor",
    "args": [
     {
      "name": "anchor",
      "type": "uint",
      "enum": "anchor"
     }
    ],
    "opcode": 3
   },
   {
    "name": "set_gravity",
    "args": [
     {
      "name": "gravity",
      "type": "uint",
      "enum": "gravity"
     }
    ],
    "opcode": 4
   },
   {
    "name": "set_constraint_adjustment",
    "args": [
     {
      "name": "constraint_adjustment",
      "type": "uint",
      "enum": "constraint_adjustment"
     }
    ],
    "opcode": 5
   },
   {
    "name": "set_offset",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     }
    ],
    "opcode": 6
   },
   {
    "name": "set_reactive",
    "since": "3",
    "args": [],
    "opcode": 7
   },
   {
    "name": "set_parent_size",
    "since": "3",
    "args": [
     {
      "name": "parent_width",
      "type": "int"
     },
     {
      "name": "parent_height",
      "type": "int"
     }
    ],
    "opcode": 8
   },
   {
    "name": "set_parent_configure",
    "since": "3",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 9
   }
  ],
  "version": "6",
  "description": "child surface positioner\n\nThe xdg_positioner provides a collection of rules for the placement of a\nchild surface relative to a parent surface. Rules can be defined to ensure\nthe child surface remains within the visible area's borders, and to\nspecify how the child surface changes its position, such as sliding along\nan axis, or flipping around a rectangle. These positioner-created rules are\nconstrained by the requirement that a child surface must intersect with or\nbe at least partially adjacent to its parent surface.\n\nSee the various requests for details about possible rules.\n\nAt the time of the request, the compositor makes a copy of the rules\nspecified by the xdg_positioner. Thus, after the request is complete the\nxdg_positioner object can be destroyed or reused; further changes to the\nobject will have no effect on previous usages.\n\nFor an xdg_positioner object to be considered complete, it must have a\nnon-zero size set by set_size, and a non-zero anchor rectangle set by\nset_anchor_rect. Passing an incomplete xdg_positioner object when\npositioning a surface raises an invalid_positioner error.\n"
 },
 "xdg_surface": {
  "events": [
   {
    "name": "configure",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 0
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "get_toplevel",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xdg_toplevel"
     }
    ],
    "opcode": 1
   },
   {
    "name": "get_popup",
    "args": [
     {
      "name": "id",
      "type": "new_id",
      "interface": "xdg_popup"
     },
     {
      "name": "parent",
      "type": "object",
      "interface": "xdg_surface",
      "allow-null": "true"
     },
     {
      "name": "positioner",
      "type": "object",
      "interface": "xdg_positioner"
     }
    ],
    "opcode": 2
   },
   {
    "name": "set_window_geometry",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 3
   },
   {
    "name": "ack_configure",
    "args": [
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 4
   }
  ],
  "version": "6",
  "description": "desktop user interface surface base interface\n\nAn interface that may be implemented by a wl_surface, for\nimplementations that provide a desktop-style user interface.\n\nIt provides a base set of functionality required to construct user\ninterface elements requiring management by the compositor, such as\ntoplevel windows, menus, etc. The types of functionality are split into\nxdg_surface roles.\n\nCreating an xdg_surface does not set the role for a wl_surface. In order\nto map an xdg_surface, the client must create a role-specific object\nusing, e.g., get_toplevel, get_popup. The wl_surface for any given\nxdg_surface can have at most one role, and may not be assigned any role\nnot based on xdg_surface.\n\nA role must be assigned before any other requests are made to the\nxdg_surface object.\n\nThe client must call wl_surface.commit on the corresponding wl_surface\nfor the xdg_surface state to take effect.\n\nCreating an xdg_surface from a wl_surface which has a buffer attached or\ncommitted is a client error, and any attempts by a client to attach or\nmanipulate a buffer prior to the first xdg_surface.configure call must\nalso be treated as errors.\n\nAfter creating a role-specific object and setting it up, the client must\nperform an initial commit without any buffer attached. The compositor\nwill reply with initial wl_surface state such as\nwl_surface.preferred_buffer_scale followed by an xdg_surface.configure\nevent. The client must acknowledge it and is then allowed to attach a\nbuffer to map the surface.\n\nMapping an xdg_surface-based role surface is defined as making it\npossible for the surface to be shown by the compositor. Note that\na mapped surface is not guaranteed to be visible once it is mapped.\n\nFor an xdg_surface to be mapped by the compositor, the following\nconditions must be met:\n(1) the client has assigned an xdg_surface-based role to the surface\n(2) the client has set and committed the xdg_surface state and the\nrole-dependent state to the surface\n(3) the client has committed a buffer to the surface\n\nA newly-unmapped surface is considered to have met condition (1) out\nof the 3 required conditions for mapping a surface if its role surface\nhas not been destroyed, i.e. the client must perform the initial commit\nagain before attaching a buffer.\n"
 },
 "xdg_toplevel": {
  "events": [
   {
    "name": "configure",
    "args": [
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     },
     {
      "name": "states",
      "type": "array"
     }
    ],
    "opcode": 0
   },
   {
    "name": "close",
    "args": [],
    "opcode": 1
   },
   {
    "name": "configure_bounds",
    "since": "4",
    "args": [
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 2
   },
   {
    "name": "wm_capabilities",
    "since": "5",
    "args": [
     {
      "name": "capabilities",
      "type": "array"
     }
    ],
    "opcode": 3
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "set_parent",
    "args": [
     {
      "name": "parent",
      "type": "object",
      "interface": "xdg_toplevel",
      "allow-null": "true"
     }
    ],
    "opcode": 1
   },
   {
    "name": "set_title",
    "args": [
     {
      "name": "title",
      "type": "string"
     }
    ],
    "opcode": 2
   },
   {
    "name": "set_app_id",
    "args": [
     {
      "name": "app_id",
      "type": "string"
     }
    ],
    "opcode": 3
   },
   {
    "name": "show_window_menu",
    "args": [
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     },
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     }
    ],
    "opcode": 4
   },
   {
    "name": "move",
    "args": [
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     },
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 5
   },
   {
    "name": "resize",
    "args": [
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     },
     {
      "name": "serial",
      "type": "uint"
     },
     {
      "name": "edges",
      "type": "uint",
      "enum": "resize_edge"
     }
    ],
    "opcode": 6
   },
   {
    "name": "set_max_size",
    "args": [
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 7
   },
   {
    "name": "set_min_size",
    "args": [
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 8
   },
   {
    "name": "set_maximized",
    "args": [],
    "opcode": 9
   },
   {
    "name": "unset_maximized",
    "args": [],
    "opcode": 10
   },
   {
    "name": "set_fullscreen",
    "args": [
     {
      "name": "output",
      "type": "object",
      "interface": "wl_output",
      "allow-null": "true"
     }
    ],
    "opcode": 11
   },
   {
    "name": "unset_fullscreen",
    "args": [],
    "opcode": 12
   },
   {
    "name": "set_minimized",
    "args": [],
    "opcode": 13
   }
  ],
  "version": "6",
  "description": "toplevel surface\n\nThis interface defines an xdg_surface role which allows a surface to,\namong other things, set window-like properties such as maximize,\nfullscreen, and minimize, set application-specific metadata like title and\nid, and well as trigger user interactive operations such as interactive\nresize and move.\n\nA xdg_toplevel by default is responsible for providing the full intended\nvisual representation of the toplevel, which depending on the window\nstate, may mean things like a title bar, window controls and drop shadow.\n\nUnmapping an xdg_toplevel means that the surface cannot be shown\nby the compositor until it is explicitly mapped again.\nAll active operations (e.g., move, resize) are canceled and all\nattributes (e.g. title, state, stacking, ...) are discarded for\nan xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to\nthe state it had right after xdg_surface.get_toplevel. The client\ncan re-map the toplevel by performing a commit without any buffer\nattached, waiting for a configure event and handling it as usual (see\nxdg_surface description).\n\nAttaching a null buffer to a toplevel unmaps the surface.\n"
 },
 "xdg_popup": {
  "events": [
   {
    "name": "configure",
    "args": [
     {
      "name": "x",
      "type": "int"
     },
     {
      "name": "y",
      "type": "int"
     },
     {
      "name": "width",
      "type": "int"
     },
     {
      "name": "height",
      "type": "int"
     }
    ],
    "opcode": 0
   },
   {
    "name": "popup_done",
    "args": [],
    "opcode": 1
   },
   {
    "name": "repositioned",
    "since": "3",
    "args": [
     {
      "name": "token",
      "type": "uint"
     }
    ],
    "opcode": 2
   }
  ],
  "methods": [
   {
    "name": "destroy",
    "type": "destructor",
    "args": [],
    "opcode": 0
   },
   {
    "name": "grab",
    "args": [
     {
      "name": "seat",
      "type": "object",
      "interface": "wl_seat"
     },
     {
      "name": "serial",
      "type": "uint"
     }
    ],
    "opcode": 1
   },
   {
    "name": "reposition",
    "since": "3",
    "args": [
     {
      "name": "positioner",
      "type": "object",
      "interface": "xdg_positioner"
     },
     {
      "name": "token",
      "type": "uint"
     }
    ],
    "opcode": 2
   }
  ],
  "version": "6",
  "description": "short-lived, popup surfaces for menus\n\nA popup surface is a short-lived, temporary surface. It can be used to\nimplement for example menus, popovers, tooltips and other similar user\ninterface concepts.\n\nA popup can be made to take an explicit grab. See xdg_popup.grab for\ndetails.\n\nWhen the popup is dismissed, a popup_done event will be sent out, and at\nthe same time the surface will be unmapped. See the xdg_popup.popup_done\nevent for details.\n\nExplicitly destroying the xdg_popup object will also dismiss the popup and\nunmap the surface. Clients that want to dismiss the popup when another\nsurface of their own is clicked should dismiss the popup using the destroy\nrequest.\n\nA newly created xdg_popup will be stacked on top of all previously created\nxdg_popup surfaces associated with the same xdg_toplevel.\n\nThe parent of an xdg_popup must be mapped (see the xdg_surface\ndescription) before the xdg_popup itself.\n\nThe client must call wl_surface.commit on the corresponding wl_surface\nfor the xdg_popup state to take effect.\n"
 }
}